{"version":3,"file":"schema.esm.js","sources":["../src/utils.ts","../src/schema.ts","../src/types/array.ts","../src/types/basic.ts","../src/types/defaults.ts","../src/types/dict.ts","../src/types/discriminatedObject.ts","../src/types/lazy.ts","../src/types/literal.ts","../src/types/nullable.ts","../src/types/numberEnum.ts","../src/types/object.ts","../src/types/optional.ts","../src/types/stringEnum.ts","../src/types/unknown.ts"],"sourcesContent":["/**\r\n * Utilities for internal library usage\r\n */\r\n\r\nimport { Schema, SchemaContextCreator, SchemaValidationError } from './schema';\r\n\r\nexport function arrayEntries<T>(arr: T[]) {\r\n  const entries: [number, T][] = [];\r\n  for (let index = 0; index < arr.length; index++) {\r\n    const element = arr[index];\r\n    entries.push([index, element]);\r\n  }\r\n  return entries;\r\n}\r\n\r\nexport function objectEntries<T extends Record<string, unknown>>(\r\n  obj: T\r\n): [Extract<keyof T, string>, T[keyof T]][] {\r\n  let ownProps = Object.keys(obj),\r\n    i = ownProps.length,\r\n    resArray = new Array(i); // preallocate the Array\r\n  while (i--) resArray[i] = [ownProps[i], obj[ownProps[i]]];\r\n\r\n  return resArray;\r\n}\r\n\r\nexport function literalToString(value: any): string {\r\n  return typeof value === 'string'\r\n    ? `\"${value.replace(/\"/g, '\"')}\"`\r\n    : `${value}`;\r\n}\r\n\r\nexport function identityFn<T>(value: T): T {\r\n  return value;\r\n}\r\n\r\nexport function toValidator(\r\n  fn: (value: unknown) => boolean\r\n): (value: unknown, ctxt: SchemaContextCreator) => SchemaValidationError[] {\r\n  return (value, ctxt) => (fn(value) ? [] : ctxt.fail());\r\n}\r\n\r\n/**\r\n * Schema in which the mapping and unmapping is done the same way\r\n */\r\nexport interface SymmetricSchema<T> {\r\n  type: string;\r\n  validate: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: T, ctxt: SchemaContextCreator) => T;\r\n}\r\n\r\n/**\r\n * Create a schema in which the mapping and unmapping is done the same way\r\n */\r\nexport function createSymmetricSchema<T>(\r\n  schema: SymmetricSchema<T>\r\n): Schema<T, T> {\r\n  return createBasicSchema({\r\n    type: () => schema.type,\r\n    validateBeforeMap: schema.validate,\r\n    validateBeforeUnmap: schema.validate,\r\n    map: schema.map,\r\n    unmap: schema.map,\r\n  });\r\n}\r\n\r\ninterface BasicSchema<T, S = unknown> {\r\n  type: () => string;\r\n  validateBeforeMap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  validateBeforeUnmap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: S, ctxt: SchemaContextCreator) => T;\r\n  unmap: (value: T, ctxt: SchemaContextCreator) => S;\r\n}\r\n\r\n/** Create a basic schema where XML mapping and validation is the same as for JSON */\r\nfunction createBasicSchema<T, S>(basicSchema: BasicSchema<T, S>): Schema<T, S> {\r\n  return {\r\n    ...basicSchema,\r\n    validateBeforeMapXml: basicSchema.validateBeforeUnmap,\r\n    mapXml: basicSchema.map,\r\n    unmapXml: basicSchema.unmap,\r\n  };\r\n}\r\n\r\nexport function isNumericString(value: unknown): value is number | string {\r\n  return (\r\n    typeof value === 'number' ||\r\n    (typeof value === 'string' && !isNaN(value as any))\r\n  );\r\n}\r\n\r\nexport function coerceNumericStringToNumber(value: number | string): number {\r\n  return typeof value === 'number' ? value : +value;\r\n}\r\n\r\nexport function once<Args extends any[], R>(\r\n  func: (...args: Args) => R\r\n): (...args: Args) => R {\r\n  var ran = false,\r\n    memo: R;\r\n  return function(this: any, ...args) {\r\n    if (ran) return memo;\r\n    ran = true;\r\n    memo = func.apply(this, args);\r\n    return memo;\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a copy of the object with the given keys omitted.\r\n */\r\nexport function omitKeysFromObject(\r\n  object: Record<string, unknown>,\r\n  keysToOmit: string[]\r\n): Record<string, unknown> {\r\n  const omitSet = new Set(keysToOmit);\r\n  const output: Record<string, unknown> = {};\r\n  for (const key in object) {\r\n    if (\r\n      Object.prototype.hasOwnProperty.call(object, key) &&\r\n      !omitSet.has(key)\r\n    ) {\r\n      output[key] = object[key];\r\n    }\r\n  }\r\n  return output;\r\n}\r\n\r\nexport function objectKeyEncode(key: string): string {\r\n  return key.indexOf(' ') !== -1 ? literalToString(key) : key;\r\n}\r\n","import flatten from 'lodash.flatten';\r\nimport { objectKeyEncode } from './utils';\r\n\r\n/**\r\n * Schema defines a type and its validation and mapping functions.\r\n */\r\nexport interface Schema<T, S = any> {\r\n  type: () => string;\r\n  validateBeforeMap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  validateBeforeUnmap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: S, ctxt: SchemaContextCreator) => T;\r\n  unmap: (value: T, ctxt: SchemaContextCreator) => S;\r\n\r\n  validateBeforeMapXml: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  mapXml: (value: any, ctxt: SchemaContextCreator) => T;\r\n  unmapXml: (value: T, ctxt: SchemaContextCreator) => any;\r\n}\r\n\r\n/**\r\n * Type for a Schema\r\n */\r\nexport type SchemaType<T extends Schema<any, any>> = ReturnType<T['map']>;\r\n\r\n/**\r\n * Mapped type for the Schema\r\n */\r\nexport type SchemaMappedType<T extends Schema<any, any>> = ReturnType<\r\n  T['unmap']\r\n>;\r\n\r\n/**\r\n * Schema context when validating or mapping\r\n */\r\nexport interface SchemaContext {\r\n  readonly value: unknown;\r\n  readonly type: string;\r\n  readonly branch: Array<unknown>;\r\n  readonly path: Array<string | number>;\r\n}\r\n\r\n/**\r\n * SchemaContextCreator provides schema context as well as utility methods for\r\n * interacting with the context from inside the validation or mapping methods.\r\n */\r\nexport interface SchemaContextCreator extends SchemaContext {\r\n  createChild<T, S extends Schema<any, any>>(\r\n    key: any,\r\n    value: T,\r\n    childSchema: S\r\n  ): SchemaContextCreator;\r\n  flatmapChildren<K extends string | number, T, S extends Schema<any, any>, R>(\r\n    items: [K, T][],\r\n    itemSchema: S,\r\n    mapper: (item: [K, T], childCtxt: SchemaContextCreator) => R[]\r\n  ): R[];\r\n  mapChildren<K extends string | number, T, S extends Schema<any, any>, R>(\r\n    items: [K, T][],\r\n    itemSchema: S,\r\n    mapper: (item: [K, T], childCtxt: SchemaContextCreator) => R\r\n  ): R[];\r\n  fail(message?: string): SchemaValidationError[];\r\n}\r\n\r\n/**\r\n * Validation result after running validation.\r\n */\r\nexport type ValidationResult<T> =\r\n  | { errors: false; result: T }\r\n  | { errors: SchemaValidationError[] };\r\n\r\n/**\r\n * Schema validation error\r\n */\r\nexport interface SchemaValidationError extends SchemaContext {\r\n  readonly message?: string;\r\n}\r\n\r\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after JSON deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndMap<T extends Schema<any, any>>(\r\n  value: SchemaMappedType<T>,\r\n  schema: T\r\n): ValidationResult<SchemaType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeMap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.map(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before JSON serializatin.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndUnmap<T extends Schema<any, any>>(\r\n  value: SchemaType<T>,\r\n  schema: T\r\n): ValidationResult<SchemaMappedType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeUnmap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.unmap(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after XML deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndMapXml<T extends Schema<any, any>>(\r\n  value: unknown,\r\n  schema: T\r\n): ValidationResult<SchemaType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeMapXml(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.mapXml(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before XML serialization.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndUnmapXml<T extends Schema<any, any>>(\r\n  value: SchemaType<T>,\r\n  schema: T\r\n): ValidationResult<unknown> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeUnmap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.unmapXml(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new schema context using the given value and type.\r\n */\r\nfunction createNewSchemaContext(value: unknown, type: string): SchemaContext {\r\n  return {\r\n    value,\r\n    type,\r\n    branch: [value],\r\n    path: [],\r\n  };\r\n}\r\n\r\n/**\r\n * Create a new SchemaContextCreator for the given SchemaContext.\r\n */\r\nfunction createSchemaContextCreator(\r\n  currentContext: SchemaContext\r\n): SchemaContextCreator {\r\n  const createChildContext: SchemaContextCreator['createChild'] = (\r\n    key,\r\n    value,\r\n    childSchema\r\n  ) =>\r\n    createSchemaContextCreator({\r\n      value,\r\n      type: childSchema.type(),\r\n      branch: [...currentContext.branch, value],\r\n      path: [...currentContext.path, key],\r\n    });\r\n\r\n  const mapChildren: SchemaContextCreator['mapChildren'] = (\r\n    items,\r\n    itemSchema,\r\n    mapper\r\n  ) =>\r\n    items.map(item =>\r\n      mapper(item, createChildContext(item[0], item[1], itemSchema))\r\n    );\r\n\r\n  return {\r\n    ...currentContext,\r\n    createChild: createChildContext,\r\n    flatmapChildren: (...args) => flatten(mapChildren(...args)),\r\n    mapChildren: mapChildren,\r\n    fail: message => [\r\n      {\r\n        ...currentContext,\r\n        message: createErrorMessage(currentContext, message),\r\n      },\r\n    ],\r\n  };\r\n}\r\n\r\nfunction createErrorMessage(ctxt: SchemaContext, message?: string): string {\r\n  message =\r\n    (message ??\r\n      `Expected value to be of type '${\r\n        ctxt.type\r\n      }' but found '${typeof ctxt.value}'.`) +\r\n    '\\n' +\r\n    `\\nGiven value: ${JSON.stringify(ctxt.value)}` +\r\n    `\\nType: '${typeof ctxt.value}'` +\r\n    `\\nExpected type: '${ctxt.type}'`;\r\n\r\n  if (ctxt.path.length > 0) {\r\n    const pathString = ctxt.path\r\n      .map(value => objectKeyEncode(value.toString()))\r\n      .join(' › ');\r\n    message += `\\nPath: ${pathString}`;\r\n  }\r\n\r\n  return message;\r\n}\r\n","import { Schema } from '../schema';\r\nimport { arrayEntries } from '../utils';\r\n\r\nexport interface ArrayXmlOptions {\r\n  xmlItemName: string;\r\n}\r\n\r\n/**\r\n * Create an array schema.\r\n *\r\n * The array must be a homogenous array confirming to the itemsSchema. Each item\r\n * will be mapped/unmapped using the itemsSchema.\r\n */\r\nexport function array<T, S>(\r\n  itemsSchema: Schema<T, S>,\r\n  xmlOptions?: ArrayXmlOptions\r\n): Schema<T[], S[]> {\r\n  let arraySchema: Schema<T[], S[]>;\r\n  arraySchema = {\r\n    type: () => `Array<${itemsSchema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      Array.isArray(value)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(value),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeMap(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail(),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      Array.isArray(value)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(value),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeUnmap(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail(),\r\n    map: (value, ctxt) =>\r\n      ctxt.mapChildren(arrayEntries(value), itemsSchema, (v, childCtxt) =>\r\n        itemsSchema.map(v[1], childCtxt)\r\n      ),\r\n    unmap: (value, ctxt) =>\r\n      ctxt.mapChildren(arrayEntries(value), itemsSchema, (v, childCtxt) =>\r\n        itemsSchema.unmap(v[1], childCtxt)\r\n      ),\r\n    mapXml: (value, ctxt) => {\r\n      let items = value;\r\n      if (xmlOptions?.xmlItemName) {\r\n        items = value[xmlOptions.xmlItemName];\r\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\r\n      }\r\n      return ctxt.mapChildren(\r\n        arrayEntries(items as any[]),\r\n        itemsSchema,\r\n        (v, childCtxt) => itemsSchema.mapXml(v[1], childCtxt)\r\n      );\r\n    },\r\n    unmapXml: (value, ctxt) => {\r\n      const items = ctxt.mapChildren(\r\n        arrayEntries(value),\r\n        itemsSchema,\r\n        (v, childCtxt) => itemsSchema.unmapXml(v[1], childCtxt)\r\n      );\r\n      if (xmlOptions?.xmlItemName) {\r\n        return { [xmlOptions.xmlItemName]: items };\r\n      } else {\r\n        return items;\r\n      }\r\n    },\r\n    validateBeforeMapXml: (value, ctxt) => {\r\n      let items = value;\r\n      if (xmlOptions?.xmlItemName) {\r\n        const errorMessage = `Expected array to be wrapped with XML element ${xmlOptions.xmlItemName}.`;\r\n        if (\r\n          typeof value !== 'object' ||\r\n          value === null ||\r\n          !(xmlOptions.xmlItemName in value)\r\n        ) {\r\n          return ctxt.fail(errorMessage);\r\n        }\r\n        items = (value as Record<string, unknown>)[xmlOptions.xmlItemName];\r\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\r\n      }\r\n\r\n      return Array.isArray(items)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(items),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeMapXml(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail();\r\n    },\r\n  };\r\n  return arraySchema;\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  createSymmetricSchema,\r\n  identityFn,\r\n  isNumericString,\r\n  toValidator,\r\n  coerceNumericStringToNumber,\r\n} from '../utils';\r\n\r\nfunction isValidStringValue(value: unknown): value is string {\r\n  return typeof value === 'string';\r\n}\r\n\r\n/** Create a string schema. */\r\nexport function string(): Schema<string, string> {\r\n  return createSymmetricSchema({\r\n    type: 'string',\r\n    validate: toValidator(isValidStringValue),\r\n    map: identityFn,\r\n  });\r\n}\r\n\r\n/** Create a number schema. */\r\nexport function number(): Schema<number, number> {\r\n  return createSymmetricSchema({\r\n    type: 'number',\r\n    validate: toValidator(isNumericString),\r\n    map: coerceNumericStringToNumber,\r\n  });\r\n}\r\n\r\nfunction isValidBooleanValue(value: unknown): boolean {\r\n  return (\r\n    typeof value === 'boolean' ||\r\n    (typeof value === 'string' && (value === 'true' || value === 'false'))\r\n  );\r\n}\r\n\r\n/** Create a boolean schema. */\r\nexport function boolean(): Schema<boolean, boolean> {\r\n  return createSymmetricSchema({\r\n    type: 'boolean',\r\n    validate: toValidator(isValidBooleanValue),\r\n    map: value => (typeof value === 'boolean' ? value : value === 'true'),\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\nimport { literalToString } from '../utils';\r\n\r\n/**\r\n * Create a 'defaults' schema.\r\n *\r\n * During mapping or unmapping, if the value is null or undefined, the schema\r\n * defaults to the 'defaultValue' specified in the schema.\r\n */\r\nexport function defaults<M, U, V extends M & U>(\r\n  schema: Schema<M, U>,\r\n  defaultValue: V\r\n): Schema<M, U> {\r\n  return {\r\n    type: () => `Defaults<${schema.type()},${literalToString(defaultValue)}>`,\r\n    validateBeforeMap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? [] : schema.validateBeforeMap(v, ctxt),\r\n    validateBeforeUnmap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? [] : schema.validateBeforeUnmap(v, ctxt),\r\n    map: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.map(v, ctxt),\r\n    unmap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.unmap(v, ctxt),\r\n    validateBeforeMapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue)\r\n        ? []\r\n        : schema.validateBeforeMapXml(v, ctxt),\r\n    mapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.mapXml(v, ctxt),\r\n    unmapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.unmapXml(v, ctxt),\r\n  };\r\n}\r\n\r\nfunction shouldDefault<T, V extends T>(value: T, defaultValue: V) {\r\n  return value === null || value === undefined || value === defaultValue;\r\n}\r\n","import { Schema, SchemaContextCreator, SchemaValidationError } from '../schema';\r\nimport { objectEntries } from '../utils';\r\n\r\n/**\r\n * Create a dictionary schema.\r\n *\r\n * This can be used to map/unmap a type like Record<string, something>.\r\n */\r\nexport function dict<T, S>(\r\n  itemSchema: Schema<T, S>\r\n): Schema<Record<string, T>, Record<string, S>> {\r\n  const validate = (\r\n    validateFn:\r\n      | 'validateBeforeMap'\r\n      | 'validateBeforeUnmap'\r\n      | 'validateBeforeMapXml',\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ): SchemaValidationError[] => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    const valueObject = value as Record<string, unknown>;\r\n    return ctxt.flatmapChildren(\r\n      objectEntries(valueObject),\r\n      itemSchema,\r\n      (v, childCtxt) => itemSchema[validateFn](v[1], childCtxt)\r\n    );\r\n  };\r\n\r\n  return {\r\n    type: () => `Record<string,${itemSchema.type()}>`,\r\n    validateBeforeMap: (...args) => validate('validateBeforeMap', ...args),\r\n    validateBeforeUnmap: (...args) => validate('validateBeforeUnmap', ...args),\r\n    map: (value, ctxt) => {\r\n      const output: Record<string, T> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.map(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    unmap: (value, ctxt) => {\r\n      const output: Record<string, S> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.unmap(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    validateBeforeMapXml: (...args) =>\r\n      validate('validateBeforeMapXml', ...args),\r\n    mapXml: (value, ctxt) => {\r\n      const output: Record<string, T> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.mapXml(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    unmapXml: (value, ctxt) => {\r\n      const output: Record<string, S> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.unmapXml(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n  };\r\n}\r\n\r\nexport function dictWithXmlEntries<T, S>(\r\n  itemSchema: Schema<T, S>\r\n): Schema<Record<string, T>, Record<string, S>> {\r\n  const dictSchema = dict(itemSchema);\r\n  const modifiedSchema = { ...dictSchema };\r\n\r\n  modifiedSchema.unmapXml = (value, ctxt) => {\r\n    const output: Record<string, S> = dictSchema.unmapXml(value, ctxt);\r\n\r\n    // Convert each entry to XML \"entry\" elements. The XML \"entry\" element looks\r\n    // like this: `<entry key=\"key\">value</entry>`. Note that the element name\r\n    // \"entry\" is set later at the return.\r\n    const entries = objectEntries(output).map(([key, value]) => ({\r\n      $: { key },\r\n      _: value,\r\n    }));\r\n\r\n    return { entry: entries };\r\n  };\r\n\r\n  modifiedSchema.mapXml = (value, ctxt) => {\r\n    // Empty dictionary\r\n    if (!('entry' in value)) {\r\n      return {};\r\n    }\r\n\r\n    let { entry: entries } = value as {\r\n      entry: { $: { key: string }; _: unknown }[];\r\n    };\r\n\r\n    // For a single entry, the XML parser gives a single object instead of an array.\r\n    // Make it an array for easier handling.\r\n    if (!Array.isArray(entries)) {\r\n      entries = [entries];\r\n    }\r\n\r\n    // Convert entry elements containing a key attribute and content to a dictionary.\r\n    const dictObj: Record<string, unknown> = {};\r\n    for (const item of entries) {\r\n      dictObj[item.$.key] = item._;\r\n    }\r\n\r\n    // Run validation on entry values against the item schema.\r\n    // TODO: Maintain context and path when delegating validatin\r\n    return dictSchema.mapXml(dictObj, ctxt);\r\n  };\r\n\r\n  modifiedSchema.validateBeforeMapXml = (value, ctxt) => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n\r\n    // Empty dictionary case\r\n    if (!('entry' in value)) {\r\n      return [];\r\n    }\r\n\r\n    let entries = (value as { entry: object[] })['entry'];\r\n\r\n    // Non-repeating XML elements are passed as a single-object instead of an array of objects.\r\n    // We normalize this behavior of the XML parser.\r\n    if (!Array.isArray(entries)) {\r\n      entries = [entries];\r\n    }\r\n\r\n    // Dictionary for all entries\r\n    const dictObj: Record<string, unknown> = {};\r\n\r\n    for (let index = 0; index < entries.length; index++) {\r\n      const entry = entries[index];\r\n      // Fail if entry is not an XML element object.\r\n      if (typeof entry !== 'object' || entry === null) {\r\n        return ctxt.fail('Expected \"entry\" to be an XML element.');\r\n      }\r\n\r\n      // Fail if entry does not have an attribute named key.\r\n      if (!('$' in entry) || !('key' in (entry as { $: object }).$)) {\r\n        return ctxt.fail(\r\n          'Expected \"entry\" element to have an attribute named \"key\".'\r\n        );\r\n      }\r\n\r\n      // Set entry in dictionary\r\n      const typedEntry = entry as { $: { key: string }; _: unknown };\r\n      dictObj[typedEntry.$.key] = typedEntry._;\r\n    }\r\n\r\n    // Check all entry values against the item schema.\r\n    // TODO: Maintain context and path when delegating validation\r\n    return dictSchema.validateBeforeMapXml(dictObj, ctxt);\r\n  };\r\n\r\n  return modifiedSchema;\r\n}\r\n","import { Schema, SchemaMappedType, SchemaType } from '../schema';\r\nimport { objectEntries } from '../utils';\r\nimport { ObjectXmlOptions } from './object';\r\n\r\nexport function discriminatedObject<\r\n  TSchema extends Schema<any, any>,\r\n  TDiscrimProp extends keyof SchemaType<TSchema>,\r\n  TDiscrimMappedProp extends keyof SchemaMappedType<TSchema>,\r\n  TDiscrimMap extends Record<string, TSchema>\r\n>(\r\n  discriminatorMappedPropName: TDiscrimMappedProp,\r\n  discriminatorPropName: TDiscrimProp,\r\n  discriminatorMap: TDiscrimMap,\r\n  defaultDiscriminator: keyof TDiscrimMap,\r\n  xmlOptions?: ObjectXmlOptions\r\n): Schema<any, any> {\r\n  const schemaSelector = (\r\n    value: unknown,\r\n    discriminatorProp: string | TDiscrimProp | TDiscrimMappedProp,\r\n    isAttr: boolean = false\r\n  ) => {\r\n    if (\r\n      typeof value === 'object' &&\r\n      value !== null &&\r\n      ((isAttr && xmlObjectHasAttribute(value, discriminatorProp as string)) ||\r\n        (!isAttr && (discriminatorProp as string) in value))\r\n    ) {\r\n      const discriminatorValue = isAttr\r\n        ? (value as { $: Record<string, unknown> })['$'][\r\n            discriminatorProp as string\r\n          ]\r\n        : (value as Record<typeof discriminatorProp, unknown>)[\r\n            discriminatorProp\r\n          ];\r\n      if (\r\n        typeof discriminatorValue === 'string' &&\r\n        discriminatorValue in discriminatorMap\r\n      ) {\r\n        return discriminatorMap[discriminatorValue];\r\n      }\r\n    }\r\n    return discriminatorMap[defaultDiscriminator];\r\n  };\r\n  return {\r\n    type: () =>\r\n      `DiscriminatedUnion<${discriminatorPropName},[${objectEntries(\r\n        discriminatorMap\r\n      )\r\n        .map(([_, v]) => v.type)\r\n        .join(',')}]>`,\r\n    map: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorPropName).map(value, ctxt),\r\n    unmap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).unmap(value, ctxt),\r\n    validateBeforeMap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorPropName).validateBeforeMap(\r\n        value,\r\n        ctxt\r\n      ),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).validateBeforeUnmap(\r\n        value,\r\n        ctxt\r\n      ),\r\n    mapXml: (value, ctxt) =>\r\n      schemaSelector(\r\n        value,\r\n        xmlOptions?.xmlName ?? discriminatorPropName,\r\n        xmlOptions?.isAttr\r\n      ).mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).unmapXml(value, ctxt),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      schemaSelector(\r\n        value,\r\n        xmlOptions?.xmlName ?? discriminatorPropName,\r\n        xmlOptions?.isAttr\r\n      ).validateBeforeMapXml(value, ctxt),\r\n  };\r\n}\r\n\r\nfunction xmlObjectHasAttribute(value: object, prop: string): boolean {\r\n  return (\r\n    '$' in value &&\r\n    typeof (value as { $: unknown })['$'] === 'object' &&\r\n    (prop as string) in (value as { $: Record<string, unknown> })['$']\r\n  );\r\n}\r\n","import { Schema } from '../schema';\r\nimport { once } from '../utils';\r\n\r\n/**\r\n * Create a schema that lazily delegates to the given schema.\r\n */\r\nexport function lazy<T, V>(schemaFn: () => Schema<T, V>): Schema<T, V> {\r\n  const getSchema = once(schemaFn); // Memoize schema\r\n  return {\r\n    type: () => `Lazy<${getSchema().type()}>`,\r\n    map: (...args) => getSchema().map(...args),\r\n    unmap: (...args) => getSchema().unmap(...args),\r\n    validateBeforeMap: (...args) => getSchema().validateBeforeMap(...args),\r\n    validateBeforeUnmap: (...args) => getSchema().validateBeforeUnmap(...args),\r\n    mapXml: (...args) => getSchema().mapXml(...args),\r\n    unmapXml: (...args) => getSchema().unmapXml(...args),\r\n    validateBeforeMapXml: (...args) =>\r\n      getSchema().validateBeforeMapXml(...args),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport { createSymmetricSchema, literalToString, toValidator } from '../utils';\r\n\r\n/**\r\n * Create a literal schema.\r\n *\r\n * This schema always unmaps/maps to the constant value provided in the schema,\r\n * regardless of the value being mapped/unmapped. The validation always passes.\r\n */\r\nexport function literal<T extends boolean>(literalValue: T): Schema<T, T>;\r\nexport function literal<T extends number>(literalValue: T): Schema<T, T>;\r\nexport function literal<T extends string>(literalValue: T): Schema<T, T>;\r\nexport function literal<T>(literalValue: T): Schema<T, T>;\r\nexport function literal<T>(literalValue: T): Schema<T, T> {\r\n  const validate = (value: unknown): value is T => literalValue === value;\r\n  const map = () => literalValue;\r\n  return createSymmetricSchema({\r\n    type: `Literal<${literalToString(literalValue)}>`,\r\n    validate: toValidator(validate),\r\n    map: map,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\n\r\n/**\r\n * Creates a nullable schema.\r\n *\r\n * The nullable schema allows null values or the values allowed by the given\r\n * 'schema'.\r\n */\r\nexport function nullable<T, S>(\r\n  schema: Schema<T, S>\r\n): Schema<T | null, S | null> {\r\n  return {\r\n    type: () => `Nullable<${schema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeMap(value, ctxt),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeUnmap(value, ctxt),\r\n    map: (value, ctxt) => (value === null ? null : schema.map(value, ctxt)),\r\n    unmap: (value, ctxt) => (value === null ? null : schema.unmap(value, ctxt)),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeMapXml(value, ctxt),\r\n    mapXml: (value, ctxt) =>\r\n      value === null ? null : schema.mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      value === null ? null : schema.unmapXml(value, ctxt),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  coerceNumericStringToNumber,\r\n  createSymmetricSchema,\r\n  isNumericString,\r\n  toValidator,\r\n} from '../utils';\r\n\r\nfunction createEnumChecker<T extends string, TEnumValue extends number>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n) {\r\n  const enumValues = Object.values(enumVariable);\r\n  return (value: unknown): value is TEnumValue =>\r\n    isNumericString(value) &&\r\n    enumValues.includes(coerceNumericStringToNumber(value));\r\n}\r\n\r\n/**\r\n * Create a schema for a number enumeration.\r\n */\r\nexport function numberEnum<T extends string, TEnumValue extends number>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n): Schema<TEnumValue, TEnumValue> {\r\n  const validate = toValidator(createEnumChecker(enumVariable));\r\n\r\n  return createSymmetricSchema({\r\n    type: `Enum<${Object.values(enumVariable)\r\n      .filter(v => typeof v === 'number')\r\n      .join(',')}>`,\r\n    map: coerceNumericStringToNumber as (value: unknown) => TEnumValue,\r\n    validate: validate,\r\n  });\r\n}\r\n","import {\r\n  Schema,\r\n  SchemaContextCreator,\r\n  SchemaMappedType,\r\n  SchemaType,\r\n  SchemaValidationError,\r\n} from '../schema';\r\nimport { OptionalizeObject } from '../typeUtils';\r\nimport {\r\n  literalToString,\r\n  objectEntries,\r\n  objectKeyEncode,\r\n  omitKeysFromObject,\r\n} from '../utils';\r\n\r\ntype AnyObjectSchema = Record<\r\n  string,\r\n  [string, Schema<any, any>, ObjectXmlOptions?]\r\n>;\r\n\r\ntype AllValues<T extends AnyObjectSchema> = {\r\n  [P in keyof T]: { key: P; value: T[P][0]; schema: T[P][1] };\r\n}[keyof T];\r\n\r\nexport type MappedObjectType<T extends AnyObjectSchema> = OptionalizeObject<\r\n  {\r\n    [P in AllValues<T>['value']]: SchemaMappedType<\r\n      Extract<AllValues<T>, { value: P }>['schema']\r\n    >;\r\n  }\r\n>;\r\n\r\nexport type ObjectType<T extends AnyObjectSchema> = OptionalizeObject<\r\n  {\r\n    [K in keyof T]: SchemaType<T[K][1]>;\r\n  }\r\n>;\r\n\r\nexport interface ObjectXmlOptions {\r\n  isAttr?: boolean;\r\n  xmlName?: string;\r\n}\r\n\r\nexport interface StrictObjectSchema<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n> extends Schema<ObjectType<T>, MappedObjectType<T>> {\r\n  readonly objectSchema: T;\r\n}\r\n\r\nexport interface ObjectSchema<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>\r\n  extends Schema<\r\n    ObjectType<T> & { [key: string]: unknown },\r\n    MappedObjectType<T> & { [key: string]: unknown }\r\n  > {\r\n  readonly objectSchema: T;\r\n}\r\n\r\n/**\r\n * Create a Strict Object type schema.\r\n *\r\n * A strict-object does not allow additional properties during mapping or\r\n * unmapping. Additional properties will result in a validation error.\r\n */\r\nexport function strictObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): StrictObjectSchema<V, T> {\r\n  const schema = internalObject(objectSchema, false, false);\r\n  schema.type = () =>\r\n    `StrictObject<{${Object.keys(objectSchema)\r\n      .map(objectKeyEncode)\r\n      .join(',')}}>`;\r\n  return schema;\r\n}\r\n\r\n/**\r\n * Create an Expandable Object type schema.\r\n *\r\n * The object schema allows additional properties during mapping and unmapping. The\r\n * additional properties are copied over as is.\r\n */\r\nexport function expandoObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): ObjectSchema<V, T> {\r\n  return internalObject(objectSchema, true, true);\r\n}\r\n\r\n/**\r\n * Create an Object Type schema.\r\n *\r\n * The Object schema allows additional properties during mapping and unmapping\r\n * but discards them.\r\n */\r\nexport function object<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): StrictObjectSchema<V, T> {\r\n  const schema = internalObject(objectSchema, true, false);\r\n  schema.type = () =>\r\n    `Object<{${Object.keys(objectSchema)\r\n      .map(objectKeyEncode)\r\n      .join(',')}}>`;\r\n  return schema;\r\n}\r\n\r\n/**\r\n * Create a strict-object schema that extends an existing schema.\r\n */\r\nexport function extendStrictObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: StrictObjectSchema<V, T>,\r\n  objectSchema: B\r\n): StrictObjectSchema<string, T & B> {\r\n  return strictObject({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Create an object schema that extends an existing schema.\r\n */\r\nexport function extendExpandoObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: ObjectSchema<V, T>,\r\n  objectSchema: B\r\n): ObjectSchema<string, T & B> {\r\n  return expandoObject({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Create an Object schema that extends an existing object schema.\r\n */\r\nexport function extendObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: StrictObjectSchema<V, T>,\r\n  objectSchema: B\r\n): StrictObjectSchema<string, T & B> {\r\n  return object({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Internal utility to create object schema with different options.\r\n */\r\nfunction internalObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  objectSchema: T,\r\n  skipValidateAdditionalProps: boolean,\r\n  mapAdditionalProps: boolean\r\n): StrictObjectSchema<V, T> {\r\n  const keys = Object.keys(objectSchema);\r\n  const reverseObjectSchema = createReverseObjectSchema<T>(objectSchema);\r\n  const xmlMappingInfo = getXmlPropMappingForObjectSchema(objectSchema);\r\n  const xmlObjectSchema = createXmlObjectSchema(objectSchema);\r\n  const reverseXmlObjectSchema = createReverseXmlObjectSchema(xmlObjectSchema);\r\n  return {\r\n    type: () => `Object<{${keys.map(objectKeyEncode).join(',')},...}>`,\r\n    validateBeforeMap: validateObject(\r\n      objectSchema,\r\n      'validateBeforeMap',\r\n      skipValidateAdditionalProps\r\n    ),\r\n    validateBeforeUnmap: validateObject(\r\n      reverseObjectSchema,\r\n      'validateBeforeUnmap',\r\n      skipValidateAdditionalProps\r\n    ),\r\n    map: mapObject(objectSchema, 'map', mapAdditionalProps),\r\n    unmap: mapObject(reverseObjectSchema, 'unmap', mapAdditionalProps),\r\n    validateBeforeMapXml: validateObjectBeforeMapXml(\r\n      objectSchema,\r\n      xmlMappingInfo,\r\n      skipValidateAdditionalProps\r\n    ),\r\n    mapXml: mapObjectFromXml(xmlObjectSchema, mapAdditionalProps),\r\n    unmapXml: unmapObjectToXml(reverseXmlObjectSchema, mapAdditionalProps),\r\n    objectSchema: objectSchema,\r\n  };\r\n}\r\n\r\nfunction validateObjectBeforeMapXml(\r\n  objectSchema: Record<string, [string, Schema<any>, ObjectXmlOptions?]>,\r\n  xmlMappingInfo: ReturnType<typeof getXmlPropMappingForObjectSchema>,\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  const { elementsToProps, attributesToProps } = xmlMappingInfo;\r\n  return (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ): SchemaValidationError[] => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    const valueObject = value as {\r\n      $?: Record<string, unknown>;\r\n      [key: string]: unknown;\r\n    };\r\n    let { $: attributes, ...elements } = valueObject;\r\n    attributes = attributes ?? {};\r\n\r\n    // Validate all known elements and attributes using the schema\r\n    return [\r\n      ...validateValueObject({\r\n        validationMethod: 'validateBeforeMapXml',\r\n        propTypeName: 'child elements',\r\n        propTypePrefix: 'element',\r\n        valueTypeName: 'element',\r\n        propMapping: elementsToProps,\r\n        objectSchema,\r\n        valueObject: elements,\r\n        ctxt,\r\n        allowAdditionalProperties,\r\n      }),\r\n      ...validateValueObject({\r\n        validationMethod: 'validateBeforeMapXml',\r\n        propTypeName: 'attributes',\r\n        propTypePrefix: '@',\r\n        valueTypeName: 'element',\r\n        propMapping: attributesToProps,\r\n        objectSchema,\r\n        valueObject: attributes,\r\n        ctxt,\r\n        allowAdditionalProperties,\r\n      }),\r\n    ];\r\n  };\r\n}\r\n\r\nfunction mapObjectFromXml(\r\n  xmlObjectSchema: XmlObjectSchema,\r\n  allowAdditionalProps: boolean\r\n) {\r\n  const { elementsSchema, attributesSchema } = xmlObjectSchema;\r\n  const mapElements = mapObject(elementsSchema, 'mapXml', allowAdditionalProps);\r\n  const mapAttributes = mapObject(\r\n    attributesSchema,\r\n    'mapXml',\r\n    false // Always false; additional attributes are handled differently below.\r\n  );\r\n\r\n  // These are later used to omit know attribute props from the attributes object\r\n  // so that the remaining props can be copied over as additional props.\r\n  const attributeKeys = objectEntries(attributesSchema).map(\r\n    ([_, [name]]) => name\r\n  );\r\n\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    const valueObject = value as {\r\n      $?: Record<string, unknown>;\r\n      [key: string]: unknown;\r\n    };\r\n    let { $: attributes, ...elements } = valueObject;\r\n    attributes = attributes ?? {};\r\n\r\n    const output: Record<string, unknown> = {\r\n      ...mapAttributes(attributes, ctxt),\r\n      ...mapElements(elements, ctxt),\r\n    };\r\n\r\n    if (allowAdditionalProps) {\r\n      // Omit known attributes and copy the rest as additional attributes.\r\n      const additionalAttrs = omitKeysFromObject(attributes, attributeKeys);\r\n      if (Object.keys(additionalAttrs).length > 0) {\r\n        // These additional attrs are set in the '$' property by convention.\r\n        output['$'] = additionalAttrs;\r\n      }\r\n    }\r\n\r\n    return output;\r\n  };\r\n}\r\n\r\nfunction unmapObjectToXml(\r\n  xmlObjectSchema: XmlObjectSchema,\r\n  allowAdditionalProps: boolean\r\n) {\r\n  const { elementsSchema, attributesSchema } = xmlObjectSchema;\r\n  const mapElements = mapObject(\r\n    elementsSchema,\r\n    'unmapXml',\r\n    allowAdditionalProps\r\n  );\r\n  const mapAttributes = mapObject(\r\n    attributesSchema,\r\n    'unmapXml',\r\n    false // Always false so that element props are not copied during mapping\r\n  );\r\n\r\n  // These are later used to omit attribute props from the value object so that they\r\n  // do not get mapped during element mapping, if the allowAdditionalProps is true.\r\n  const attributeKeys = objectEntries(attributesSchema).map(\r\n    ([_, [name]]) => name\r\n  );\r\n\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    // Get additional attributes which are set in the '$' property by convention\r\n    const { $: attributes, ...rest } = value as {\r\n      $?: unknown;\r\n      [key: string]: unknown;\r\n    };\r\n\r\n    // Ensure 'attributes' is an object and non-null\r\n    const additionalAttributes =\r\n      typeof attributes === 'object' &&\r\n      attributes !== null &&\r\n      allowAdditionalProps\r\n        ? attributes\r\n        : {};\r\n\r\n    return {\r\n      ...mapElements(omitKeysFromObject(rest, attributeKeys), ctxt),\r\n      $: { ...additionalAttributes, ...mapAttributes(value, ctxt) },\r\n    };\r\n  };\r\n}\r\n\r\nfunction validateValueObject({\r\n  validationMethod,\r\n  propTypeName,\r\n  propTypePrefix,\r\n  valueTypeName,\r\n  propMapping,\r\n  objectSchema,\r\n  valueObject,\r\n  ctxt,\r\n  allowAdditionalProperties,\r\n}: {\r\n  validationMethod:\r\n    | 'validateBeforeMap'\r\n    | 'validateBeforeUnmap'\r\n    | 'validateBeforeMapXml';\r\n  propTypeName: string;\r\n  propTypePrefix: string;\r\n  valueTypeName: string;\r\n  propMapping: Record<string, string>;\r\n  objectSchema: AnyObjectSchema;\r\n  valueObject: { [key: string]: unknown };\r\n  ctxt: SchemaContextCreator;\r\n  allowAdditionalProperties: boolean;\r\n}) {\r\n  const errors: SchemaValidationError[] = [];\r\n  const missingProps: Set<string> = new Set();\r\n  const unknownProps: Set<string> = new Set(Object.keys(valueObject));\r\n\r\n  // Validate all known properties using the schema\r\n  for (const key in propMapping) {\r\n    const propName = propMapping[key];\r\n    const schema = objectSchema[propName][1];\r\n    unknownProps.delete(key);\r\n    if (key in valueObject) {\r\n      errors.push(\r\n        ...schema[validationMethod](\r\n          valueObject[key],\r\n          ctxt.createChild(propTypePrefix + key, valueObject[key], schema)\r\n        )\r\n      );\r\n    } else if (schema.type().indexOf('Optional<') !== 0) {\r\n      // Add to missing keys if it is not an optional property\r\n      missingProps.add(key);\r\n    }\r\n  }\r\n\r\n  // Create validation error for unknown properties encountered\r\n  const unknownPropsArray = Array.from(unknownProps);\r\n  if (unknownPropsArray.length > 0 && !allowAdditionalProperties) {\r\n    errors.push(\r\n      ...ctxt.fail(\r\n        `Some unknown ${propTypeName} were found in the ${valueTypeName}: ${unknownPropsArray\r\n          .map(literalToString)\r\n          .join(', ')}.`\r\n      )\r\n    );\r\n  }\r\n\r\n  // Create validation error for missing required properties\r\n  const missingPropsArray = Array.from(missingProps);\r\n  if (missingPropsArray.length > 0) {\r\n    errors.push(\r\n      ...ctxt.fail(\r\n        `Some ${propTypeName} are missing in the ${valueTypeName}: ${missingPropsArray\r\n          .map(literalToString)\r\n          .join(', ')}.`\r\n      )\r\n    );\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\nfunction validateObject(\r\n  objectSchema: AnyObjectSchema,\r\n  validationMethod:\r\n    | 'validateBeforeMap'\r\n    | 'validateBeforeUnmap'\r\n    | 'validateBeforeMapXml',\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  const propsMapping = getPropMappingForObjectSchema(objectSchema);\r\n  return (value: unknown, ctxt: SchemaContextCreator) => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    return validateValueObject({\r\n      validationMethod,\r\n      propTypeName: 'properties',\r\n      propTypePrefix: '',\r\n      valueTypeName: 'object',\r\n      propMapping: propsMapping,\r\n      objectSchema,\r\n      valueObject: value as Record<string, unknown>,\r\n      ctxt,\r\n      allowAdditionalProperties,\r\n    });\r\n  };\r\n}\r\n\r\nfunction mapObject<T extends AnyObjectSchema>(\r\n  objectSchema: T,\r\n  mappingFn: 'map' | 'unmap' | 'mapXml' | 'unmapXml',\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    const output: Record<string, unknown> = {};\r\n    const objectValue = value as Record<string, any>;\r\n    /** Properties seen in the object but not in the schema */\r\n    const unknownKeys = new Set(Object.keys(objectValue));\r\n\r\n    // Map known properties using the schema\r\n    for (const key in objectSchema) {\r\n      /* istanbul ignore else */\r\n      if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n        const element = objectSchema[key];\r\n        const propName = element[0];\r\n        const propValue = objectValue[propName];\r\n        unknownKeys.delete(propName);\r\n\r\n        // Skip mapping for optional properties to avoid creating properties with value 'undefined'\r\n        if (\r\n          element[1].type().indexOf('Optional<') !== 0 ||\r\n          propValue !== undefined\r\n        ) {\r\n          output[key] = element[1][mappingFn](\r\n            propValue,\r\n            ctxt.createChild(propName, propValue, element[1])\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Copy unknown properties over if additional properties flag is set\r\n    if (allowAdditionalProperties) {\r\n      unknownKeys.forEach(unknownKey => {\r\n        output[unknownKey] = objectValue[unknownKey];\r\n      });\r\n    }\r\n    return output;\r\n  };\r\n}\r\n\r\nfunction getXmlPropMappingForObjectSchema(objectSchema: AnyObjectSchema) {\r\n  const elementsToProps: Record<string, string> = {};\r\n  const attributesToProps: Record<string, string> = {};\r\n\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const [propName, , xmlOptions] = objectSchema[key];\r\n      if (xmlOptions?.isAttr === true) {\r\n        attributesToProps[xmlOptions.xmlName ?? propName] = key;\r\n      } else {\r\n        elementsToProps[xmlOptions?.xmlName ?? propName] = key;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { elementsToProps, attributesToProps };\r\n}\r\n\r\nfunction getPropMappingForObjectSchema(\r\n  objectSchema: AnyObjectSchema\r\n): Record<string, string> {\r\n  const propsMapping: Record<string, string> = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const propDef = objectSchema[key];\r\n      propsMapping[propDef[0]] = key;\r\n    }\r\n  }\r\n  return propsMapping;\r\n}\r\n\r\nfunction createReverseObjectSchema<T extends AnyObjectSchema>(\r\n  objectSchema: T\r\n): AnyObjectSchema {\r\n  const reverseObjectSchema: AnyObjectSchema = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const element = objectSchema[key];\r\n      reverseObjectSchema[element[0]] = [key, element[1], element[2]];\r\n    }\r\n  }\r\n  return reverseObjectSchema;\r\n}\r\n\r\ntype XmlObjectSchema = {\r\n  elementsSchema: AnyObjectSchema;\r\n  attributesSchema: AnyObjectSchema;\r\n};\r\n\r\nfunction createXmlObjectSchema(objectSchema: AnyObjectSchema): XmlObjectSchema {\r\n  const elementsSchema: AnyObjectSchema = {};\r\n  const attributesSchema: AnyObjectSchema = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const element = objectSchema[key];\r\n      const [serializedName, schema, xmlOptions] = element;\r\n      const xmlObjectSchema = xmlOptions?.isAttr\r\n        ? attributesSchema\r\n        : elementsSchema;\r\n      xmlObjectSchema[key] = [\r\n        xmlOptions?.xmlName ?? serializedName,\r\n        schema,\r\n        xmlOptions,\r\n      ];\r\n    }\r\n  }\r\n  return { elementsSchema, attributesSchema };\r\n}\r\n\r\nfunction createReverseXmlObjectSchema(\r\n  xmlObjectSchema: XmlObjectSchema\r\n): XmlObjectSchema {\r\n  return {\r\n    attributesSchema: createReverseObjectSchema(\r\n      xmlObjectSchema.attributesSchema\r\n    ),\r\n    elementsSchema: createReverseObjectSchema(xmlObjectSchema.elementsSchema),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\n\r\n/**\r\n * Create an optional schema.\r\n *\r\n * The optional schema allows 'undefined' or the values allowed by the given\r\n * 'schema'.\r\n */\r\nexport function optional<T, S>(\r\n  schema: Schema<T, S>\r\n): Schema<T | undefined, S | undefined> {\r\n  return {\r\n    type: () => `Optional<${schema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeMap(value, ctxt),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeUnmap(value, ctxt),\r\n    map: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.map(value, ctxt),\r\n    unmap: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.unmap(value, ctxt),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeMapXml(value, ctxt),\r\n    mapXml: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.unmapXml(value, ctxt),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  toValidator,\r\n  createSymmetricSchema,\r\n  identityFn,\r\n  literalToString,\r\n} from '../utils';\r\n\r\nfunction createEnumChecker<T extends string, TEnumValue extends string>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n) {\r\n  const enumValues = Object.values(enumVariable);\r\n  return (value: unknown): value is TEnumValue =>\r\n    typeof value === 'string' && enumValues.includes(value);\r\n}\r\n\r\n/**\r\n * Create a schema for a string enumeration.\r\n */\r\nexport function stringEnum<T extends string, TEnumValue extends string>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n): Schema<TEnumValue, TEnumValue> {\r\n  const validate = toValidator(createEnumChecker(enumVariable));\r\n\r\n  return createSymmetricSchema({\r\n    type: `Enum<${Object.values(enumVariable)\r\n      .map(literalToString)\r\n      .join(',')}>`,\r\n    map: identityFn,\r\n    validate: validate,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\nimport { createSymmetricSchema, identityFn } from '../utils';\r\n\r\n/**\r\n * Create an unknown schema.\r\n *\r\n * The unknown schema allows any value.\r\n */\r\nexport function unknown(): Schema<unknown, unknown> {\r\n  return createSymmetricSchema({\r\n    type: 'unknown',\r\n    validate: () => [],\r\n    map: identityFn,\r\n  });\r\n}\r\n"],"names":["arrayEntries","arr","entries","index","length","element","push","objectEntries","obj","ownProps","Object","keys","i","resArray","Array","literalToString","value","replace","identityFn","toValidator","fn","ctxt","fail","createSymmetricSchema","schema","createBasicSchema","type","validateBeforeMap","validate","validateBeforeUnmap","map","unmap","basicSchema","validateBeforeMapXml","mapXml","unmapXml","isNumericString","isNaN","coerceNumericStringToNumber","once","func","ran","memo","args","apply","omitKeysFromObject","object","keysToOmit","omitSet","Set","output","key","prototype","hasOwnProperty","call","has","objectKeyEncode","indexOf","validateAndMap","contextCreator","createSchemaContextCreator","createNewSchemaContext","validationResult","errors","result","validateAndUnmap","validateAndMapXml","validateAndUnmapXml","branch","path","currentContext","createChildContext","childSchema","mapChildren","items","itemSchema","mapper","item","createChild","flatmapChildren","flatten","message","createErrorMessage","JSON","stringify","pathString","toString","join","array","itemsSchema","xmlOptions","arraySchema","isArray","v","childCtxt","xmlItemName","errorMessage","isValidStringValue","string","number","isValidBooleanValue","boolean","defaults","defaultValue","shouldDefault","undefined","dict","validateFn","valueObject","propValue","dictWithXmlEntries","dictSchema","modifiedSchema","$","_","entry","dictObj","typedEntry","discriminatedObject","discriminatorMappedPropName","discriminatorPropName","discriminatorMap","defaultDiscriminator","schemaSelector","discriminatorProp","isAttr","xmlObjectHasAttribute","discriminatorValue","xmlName","prop","lazy","schemaFn","getSchema","literal","literalValue","nullable","createEnumChecker","enumVariable","enumValues","values","includes","numberEnum","filter","strictObject","objectSchema","internalObject","expandoObject","extendStrictObject","parentObjectSchema","extendExpandoObject","extendObject","skipValidateAdditionalProps","mapAdditionalProps","reverseObjectSchema","createReverseObjectSchema","xmlMappingInfo","getXmlPropMappingForObjectSchema","xmlObjectSchema","createXmlObjectSchema","reverseXmlObjectSchema","createReverseXmlObjectSchema","validateObject","mapObject","validateObjectBeforeMapXml","mapObjectFromXml","unmapObjectToXml","allowAdditionalProperties","elementsToProps","attributesToProps","attributes","elements","validateValueObject","validationMethod","propTypeName","propTypePrefix","valueTypeName","propMapping","allowAdditionalProps","elementsSchema","attributesSchema","mapElements","mapAttributes","attributeKeys","name","additionalAttrs","rest","additionalAttributes","missingProps","unknownProps","propName","add","unknownPropsArray","from","missingPropsArray","propsMapping","getPropMappingForObjectSchema","mappingFn","objectValue","unknownKeys","forEach","unknownKey","propDef","serializedName","optional","stringEnum","unknown"],"mappings":"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"}