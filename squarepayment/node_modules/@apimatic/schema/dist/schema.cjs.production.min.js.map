{"version":3,"file":"schema.cjs.production.min.js","sources":["../src/utils.ts","../src/schema.ts","../src/types/basic.ts","../src/types/defaults.ts","../src/types/dict.ts","../src/types/object.ts","../src/types/array.ts","../src/types/discriminatedObject.ts","../src/types/lazy.ts","../src/types/literal.ts","../src/types/nullable.ts","../src/types/numberEnum.ts","../src/types/optional.ts","../src/types/stringEnum.ts","../src/types/unknown.ts"],"sourcesContent":["/**\r\n * Utilities for internal library usage\r\n */\r\n\r\nimport { Schema, SchemaContextCreator, SchemaValidationError } from './schema';\r\n\r\nexport function arrayEntries<T>(arr: T[]) {\r\n  const entries: [number, T][] = [];\r\n  for (let index = 0; index < arr.length; index++) {\r\n    const element = arr[index];\r\n    entries.push([index, element]);\r\n  }\r\n  return entries;\r\n}\r\n\r\nexport function objectEntries<T extends Record<string, unknown>>(\r\n  obj: T\r\n): [Extract<keyof T, string>, T[keyof T]][] {\r\n  let ownProps = Object.keys(obj),\r\n    i = ownProps.length,\r\n    resArray = new Array(i); // preallocate the Array\r\n  while (i--) resArray[i] = [ownProps[i], obj[ownProps[i]]];\r\n\r\n  return resArray;\r\n}\r\n\r\nexport function literalToString(value: any): string {\r\n  return typeof value === 'string'\r\n    ? `\"${value.replace(/\"/g, '\"')}\"`\r\n    : `${value}`;\r\n}\r\n\r\nexport function identityFn<T>(value: T): T {\r\n  return value;\r\n}\r\n\r\nexport function toValidator(\r\n  fn: (value: unknown) => boolean\r\n): (value: unknown, ctxt: SchemaContextCreator) => SchemaValidationError[] {\r\n  return (value, ctxt) => (fn(value) ? [] : ctxt.fail());\r\n}\r\n\r\n/**\r\n * Schema in which the mapping and unmapping is done the same way\r\n */\r\nexport interface SymmetricSchema<T> {\r\n  type: string;\r\n  validate: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: T, ctxt: SchemaContextCreator) => T;\r\n}\r\n\r\n/**\r\n * Create a schema in which the mapping and unmapping is done the same way\r\n */\r\nexport function createSymmetricSchema<T>(\r\n  schema: SymmetricSchema<T>\r\n): Schema<T, T> {\r\n  return createBasicSchema({\r\n    type: () => schema.type,\r\n    validateBeforeMap: schema.validate,\r\n    validateBeforeUnmap: schema.validate,\r\n    map: schema.map,\r\n    unmap: schema.map,\r\n  });\r\n}\r\n\r\ninterface BasicSchema<T, S = unknown> {\r\n  type: () => string;\r\n  validateBeforeMap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  validateBeforeUnmap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: S, ctxt: SchemaContextCreator) => T;\r\n  unmap: (value: T, ctxt: SchemaContextCreator) => S;\r\n}\r\n\r\n/** Create a basic schema where XML mapping and validation is the same as for JSON */\r\nfunction createBasicSchema<T, S>(basicSchema: BasicSchema<T, S>): Schema<T, S> {\r\n  return {\r\n    ...basicSchema,\r\n    validateBeforeMapXml: basicSchema.validateBeforeUnmap,\r\n    mapXml: basicSchema.map,\r\n    unmapXml: basicSchema.unmap,\r\n  };\r\n}\r\n\r\nexport function isNumericString(value: unknown): value is number | string {\r\n  return (\r\n    typeof value === 'number' ||\r\n    (typeof value === 'string' && !isNaN(value as any))\r\n  );\r\n}\r\n\r\nexport function coerceNumericStringToNumber(value: number | string): number {\r\n  return typeof value === 'number' ? value : +value;\r\n}\r\n\r\nexport function once<Args extends any[], R>(\r\n  func: (...args: Args) => R\r\n): (...args: Args) => R {\r\n  var ran = false,\r\n    memo: R;\r\n  return function(this: any, ...args) {\r\n    if (ran) return memo;\r\n    ran = true;\r\n    memo = func.apply(this, args);\r\n    return memo;\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a copy of the object with the given keys omitted.\r\n */\r\nexport function omitKeysFromObject(\r\n  object: Record<string, unknown>,\r\n  keysToOmit: string[]\r\n): Record<string, unknown> {\r\n  const omitSet = new Set(keysToOmit);\r\n  const output: Record<string, unknown> = {};\r\n  for (const key in object) {\r\n    if (\r\n      Object.prototype.hasOwnProperty.call(object, key) &&\r\n      !omitSet.has(key)\r\n    ) {\r\n      output[key] = object[key];\r\n    }\r\n  }\r\n  return output;\r\n}\r\n\r\nexport function objectKeyEncode(key: string): string {\r\n  return key.indexOf(' ') !== -1 ? literalToString(key) : key;\r\n}\r\n","import flatten from 'lodash.flatten';\r\nimport { objectKeyEncode } from './utils';\r\n\r\n/**\r\n * Schema defines a type and its validation and mapping functions.\r\n */\r\nexport interface Schema<T, S = any> {\r\n  type: () => string;\r\n  validateBeforeMap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  validateBeforeUnmap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: S, ctxt: SchemaContextCreator) => T;\r\n  unmap: (value: T, ctxt: SchemaContextCreator) => S;\r\n\r\n  validateBeforeMapXml: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  mapXml: (value: any, ctxt: SchemaContextCreator) => T;\r\n  unmapXml: (value: T, ctxt: SchemaContextCreator) => any;\r\n}\r\n\r\n/**\r\n * Type for a Schema\r\n */\r\nexport type SchemaType<T extends Schema<any, any>> = ReturnType<T['map']>;\r\n\r\n/**\r\n * Mapped type for the Schema\r\n */\r\nexport type SchemaMappedType<T extends Schema<any, any>> = ReturnType<\r\n  T['unmap']\r\n>;\r\n\r\n/**\r\n * Schema context when validating or mapping\r\n */\r\nexport interface SchemaContext {\r\n  readonly value: unknown;\r\n  readonly type: string;\r\n  readonly branch: Array<unknown>;\r\n  readonly path: Array<string | number>;\r\n}\r\n\r\n/**\r\n * SchemaContextCreator provides schema context as well as utility methods for\r\n * interacting with the context from inside the validation or mapping methods.\r\n */\r\nexport interface SchemaContextCreator extends SchemaContext {\r\n  createChild<T, S extends Schema<any, any>>(\r\n    key: any,\r\n    value: T,\r\n    childSchema: S\r\n  ): SchemaContextCreator;\r\n  flatmapChildren<K extends string | number, T, S extends Schema<any, any>, R>(\r\n    items: [K, T][],\r\n    itemSchema: S,\r\n    mapper: (item: [K, T], childCtxt: SchemaContextCreator) => R[]\r\n  ): R[];\r\n  mapChildren<K extends string | number, T, S extends Schema<any, any>, R>(\r\n    items: [K, T][],\r\n    itemSchema: S,\r\n    mapper: (item: [K, T], childCtxt: SchemaContextCreator) => R\r\n  ): R[];\r\n  fail(message?: string): SchemaValidationError[];\r\n}\r\n\r\n/**\r\n * Validation result after running validation.\r\n */\r\nexport type ValidationResult<T> =\r\n  | { errors: false; result: T }\r\n  | { errors: SchemaValidationError[] };\r\n\r\n/**\r\n * Schema validation error\r\n */\r\nexport interface SchemaValidationError extends SchemaContext {\r\n  readonly message?: string;\r\n}\r\n\r\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after JSON deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndMap<T extends Schema<any, any>>(\r\n  value: SchemaMappedType<T>,\r\n  schema: T\r\n): ValidationResult<SchemaType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeMap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.map(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before JSON serializatin.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndUnmap<T extends Schema<any, any>>(\r\n  value: SchemaType<T>,\r\n  schema: T\r\n): ValidationResult<SchemaMappedType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeUnmap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.unmap(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after XML deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndMapXml<T extends Schema<any, any>>(\r\n  value: unknown,\r\n  schema: T\r\n): ValidationResult<SchemaType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeMapXml(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.mapXml(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before XML serialization.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndUnmapXml<T extends Schema<any, any>>(\r\n  value: SchemaType<T>,\r\n  schema: T\r\n): ValidationResult<unknown> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeUnmap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.unmapXml(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new schema context using the given value and type.\r\n */\r\nfunction createNewSchemaContext(value: unknown, type: string): SchemaContext {\r\n  return {\r\n    value,\r\n    type,\r\n    branch: [value],\r\n    path: [],\r\n  };\r\n}\r\n\r\n/**\r\n * Create a new SchemaContextCreator for the given SchemaContext.\r\n */\r\nfunction createSchemaContextCreator(\r\n  currentContext: SchemaContext\r\n): SchemaContextCreator {\r\n  const createChildContext: SchemaContextCreator['createChild'] = (\r\n    key,\r\n    value,\r\n    childSchema\r\n  ) =>\r\n    createSchemaContextCreator({\r\n      value,\r\n      type: childSchema.type(),\r\n      branch: [...currentContext.branch, value],\r\n      path: [...currentContext.path, key],\r\n    });\r\n\r\n  const mapChildren: SchemaContextCreator['mapChildren'] = (\r\n    items,\r\n    itemSchema,\r\n    mapper\r\n  ) =>\r\n    items.map(item =>\r\n      mapper(item, createChildContext(item[0], item[1], itemSchema))\r\n    );\r\n\r\n  return {\r\n    ...currentContext,\r\n    createChild: createChildContext,\r\n    flatmapChildren: (...args) => flatten(mapChildren(...args)),\r\n    mapChildren: mapChildren,\r\n    fail: message => [\r\n      {\r\n        ...currentContext,\r\n        message: createErrorMessage(currentContext, message),\r\n      },\r\n    ],\r\n  };\r\n}\r\n\r\nfunction createErrorMessage(ctxt: SchemaContext, message?: string): string {\r\n  message =\r\n    (message ??\r\n      `Expected value to be of type '${\r\n        ctxt.type\r\n      }' but found '${typeof ctxt.value}'.`) +\r\n    '\\n' +\r\n    `\\nGiven value: ${JSON.stringify(ctxt.value)}` +\r\n    `\\nType: '${typeof ctxt.value}'` +\r\n    `\\nExpected type: '${ctxt.type}'`;\r\n\r\n  if (ctxt.path.length > 0) {\r\n    const pathString = ctxt.path\r\n      .map(value => objectKeyEncode(value.toString()))\r\n      .join(' › ');\r\n    message += `\\nPath: ${pathString}`;\r\n  }\r\n\r\n  return message;\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  createSymmetricSchema,\r\n  identityFn,\r\n  isNumericString,\r\n  toValidator,\r\n  coerceNumericStringToNumber,\r\n} from '../utils';\r\n\r\nfunction isValidStringValue(value: unknown): value is string {\r\n  return typeof value === 'string';\r\n}\r\n\r\n/** Create a string schema. */\r\nexport function string(): Schema<string, string> {\r\n  return createSymmetricSchema({\r\n    type: 'string',\r\n    validate: toValidator(isValidStringValue),\r\n    map: identityFn,\r\n  });\r\n}\r\n\r\n/** Create a number schema. */\r\nexport function number(): Schema<number, number> {\r\n  return createSymmetricSchema({\r\n    type: 'number',\r\n    validate: toValidator(isNumericString),\r\n    map: coerceNumericStringToNumber,\r\n  });\r\n}\r\n\r\nfunction isValidBooleanValue(value: unknown): boolean {\r\n  return (\r\n    typeof value === 'boolean' ||\r\n    (typeof value === 'string' && (value === 'true' || value === 'false'))\r\n  );\r\n}\r\n\r\n/** Create a boolean schema. */\r\nexport function boolean(): Schema<boolean, boolean> {\r\n  return createSymmetricSchema({\r\n    type: 'boolean',\r\n    validate: toValidator(isValidBooleanValue),\r\n    map: value => (typeof value === 'boolean' ? value : value === 'true'),\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\nimport { literalToString } from '../utils';\r\n\r\n/**\r\n * Create a 'defaults' schema.\r\n *\r\n * During mapping or unmapping, if the value is null or undefined, the schema\r\n * defaults to the 'defaultValue' specified in the schema.\r\n */\r\nexport function defaults<M, U, V extends M & U>(\r\n  schema: Schema<M, U>,\r\n  defaultValue: V\r\n): Schema<M, U> {\r\n  return {\r\n    type: () => `Defaults<${schema.type()},${literalToString(defaultValue)}>`,\r\n    validateBeforeMap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? [] : schema.validateBeforeMap(v, ctxt),\r\n    validateBeforeUnmap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? [] : schema.validateBeforeUnmap(v, ctxt),\r\n    map: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.map(v, ctxt),\r\n    unmap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.unmap(v, ctxt),\r\n    validateBeforeMapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue)\r\n        ? []\r\n        : schema.validateBeforeMapXml(v, ctxt),\r\n    mapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.mapXml(v, ctxt),\r\n    unmapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.unmapXml(v, ctxt),\r\n  };\r\n}\r\n\r\nfunction shouldDefault<T, V extends T>(value: T, defaultValue: V) {\r\n  return value === null || value === undefined || value === defaultValue;\r\n}\r\n","import { Schema, SchemaContextCreator, SchemaValidationError } from '../schema';\r\nimport { objectEntries } from '../utils';\r\n\r\n/**\r\n * Create a dictionary schema.\r\n *\r\n * This can be used to map/unmap a type like Record<string, something>.\r\n */\r\nexport function dict<T, S>(\r\n  itemSchema: Schema<T, S>\r\n): Schema<Record<string, T>, Record<string, S>> {\r\n  const validate = (\r\n    validateFn:\r\n      | 'validateBeforeMap'\r\n      | 'validateBeforeUnmap'\r\n      | 'validateBeforeMapXml',\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ): SchemaValidationError[] => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    const valueObject = value as Record<string, unknown>;\r\n    return ctxt.flatmapChildren(\r\n      objectEntries(valueObject),\r\n      itemSchema,\r\n      (v, childCtxt) => itemSchema[validateFn](v[1], childCtxt)\r\n    );\r\n  };\r\n\r\n  return {\r\n    type: () => `Record<string,${itemSchema.type()}>`,\r\n    validateBeforeMap: (...args) => validate('validateBeforeMap', ...args),\r\n    validateBeforeUnmap: (...args) => validate('validateBeforeUnmap', ...args),\r\n    map: (value, ctxt) => {\r\n      const output: Record<string, T> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.map(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    unmap: (value, ctxt) => {\r\n      const output: Record<string, S> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.unmap(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    validateBeforeMapXml: (...args) =>\r\n      validate('validateBeforeMapXml', ...args),\r\n    mapXml: (value, ctxt) => {\r\n      const output: Record<string, T> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.mapXml(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    unmapXml: (value, ctxt) => {\r\n      const output: Record<string, S> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.unmapXml(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n  };\r\n}\r\n\r\nexport function dictWithXmlEntries<T, S>(\r\n  itemSchema: Schema<T, S>\r\n): Schema<Record<string, T>, Record<string, S>> {\r\n  const dictSchema = dict(itemSchema);\r\n  const modifiedSchema = { ...dictSchema };\r\n\r\n  modifiedSchema.unmapXml = (value, ctxt) => {\r\n    const output: Record<string, S> = dictSchema.unmapXml(value, ctxt);\r\n\r\n    // Convert each entry to XML \"entry\" elements. The XML \"entry\" element looks\r\n    // like this: `<entry key=\"key\">value</entry>`. Note that the element name\r\n    // \"entry\" is set later at the return.\r\n    const entries = objectEntries(output).map(([key, value]) => ({\r\n      $: { key },\r\n      _: value,\r\n    }));\r\n\r\n    return { entry: entries };\r\n  };\r\n\r\n  modifiedSchema.mapXml = (value, ctxt) => {\r\n    // Empty dictionary\r\n    if (!('entry' in value)) {\r\n      return {};\r\n    }\r\n\r\n    let { entry: entries } = value as {\r\n      entry: { $: { key: string }; _: unknown }[];\r\n    };\r\n\r\n    // For a single entry, the XML parser gives a single object instead of an array.\r\n    // Make it an array for easier handling.\r\n    if (!Array.isArray(entries)) {\r\n      entries = [entries];\r\n    }\r\n\r\n    // Convert entry elements containing a key attribute and content to a dictionary.\r\n    const dictObj: Record<string, unknown> = {};\r\n    for (const item of entries) {\r\n      dictObj[item.$.key] = item._;\r\n    }\r\n\r\n    // Run validation on entry values against the item schema.\r\n    // TODO: Maintain context and path when delegating validatin\r\n    return dictSchema.mapXml(dictObj, ctxt);\r\n  };\r\n\r\n  modifiedSchema.validateBeforeMapXml = (value, ctxt) => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n\r\n    // Empty dictionary case\r\n    if (!('entry' in value)) {\r\n      return [];\r\n    }\r\n\r\n    let entries = (value as { entry: object[] })['entry'];\r\n\r\n    // Non-repeating XML elements are passed as a single-object instead of an array of objects.\r\n    // We normalize this behavior of the XML parser.\r\n    if (!Array.isArray(entries)) {\r\n      entries = [entries];\r\n    }\r\n\r\n    // Dictionary for all entries\r\n    const dictObj: Record<string, unknown> = {};\r\n\r\n    for (let index = 0; index < entries.length; index++) {\r\n      const entry = entries[index];\r\n      // Fail if entry is not an XML element object.\r\n      if (typeof entry !== 'object' || entry === null) {\r\n        return ctxt.fail('Expected \"entry\" to be an XML element.');\r\n      }\r\n\r\n      // Fail if entry does not have an attribute named key.\r\n      if (!('$' in entry) || !('key' in (entry as { $: object }).$)) {\r\n        return ctxt.fail(\r\n          'Expected \"entry\" element to have an attribute named \"key\".'\r\n        );\r\n      }\r\n\r\n      // Set entry in dictionary\r\n      const typedEntry = entry as { $: { key: string }; _: unknown };\r\n      dictObj[typedEntry.$.key] = typedEntry._;\r\n    }\r\n\r\n    // Check all entry values against the item schema.\r\n    // TODO: Maintain context and path when delegating validation\r\n    return dictSchema.validateBeforeMapXml(dictObj, ctxt);\r\n  };\r\n\r\n  return modifiedSchema;\r\n}\r\n","import {\r\n  Schema,\r\n  SchemaContextCreator,\r\n  SchemaMappedType,\r\n  SchemaType,\r\n  SchemaValidationError,\r\n} from '../schema';\r\nimport { OptionalizeObject } from '../typeUtils';\r\nimport {\r\n  literalToString,\r\n  objectEntries,\r\n  objectKeyEncode,\r\n  omitKeysFromObject,\r\n} from '../utils';\r\n\r\ntype AnyObjectSchema = Record<\r\n  string,\r\n  [string, Schema<any, any>, ObjectXmlOptions?]\r\n>;\r\n\r\ntype AllValues<T extends AnyObjectSchema> = {\r\n  [P in keyof T]: { key: P; value: T[P][0]; schema: T[P][1] };\r\n}[keyof T];\r\n\r\nexport type MappedObjectType<T extends AnyObjectSchema> = OptionalizeObject<\r\n  {\r\n    [P in AllValues<T>['value']]: SchemaMappedType<\r\n      Extract<AllValues<T>, { value: P }>['schema']\r\n    >;\r\n  }\r\n>;\r\n\r\nexport type ObjectType<T extends AnyObjectSchema> = OptionalizeObject<\r\n  {\r\n    [K in keyof T]: SchemaType<T[K][1]>;\r\n  }\r\n>;\r\n\r\nexport interface ObjectXmlOptions {\r\n  isAttr?: boolean;\r\n  xmlName?: string;\r\n}\r\n\r\nexport interface StrictObjectSchema<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n> extends Schema<ObjectType<T>, MappedObjectType<T>> {\r\n  readonly objectSchema: T;\r\n}\r\n\r\nexport interface ObjectSchema<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>\r\n  extends Schema<\r\n    ObjectType<T> & { [key: string]: unknown },\r\n    MappedObjectType<T> & { [key: string]: unknown }\r\n  > {\r\n  readonly objectSchema: T;\r\n}\r\n\r\n/**\r\n * Create a Strict Object type schema.\r\n *\r\n * A strict-object does not allow additional properties during mapping or\r\n * unmapping. Additional properties will result in a validation error.\r\n */\r\nexport function strictObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): StrictObjectSchema<V, T> {\r\n  const schema = internalObject(objectSchema, false, false);\r\n  schema.type = () =>\r\n    `StrictObject<{${Object.keys(objectSchema)\r\n      .map(objectKeyEncode)\r\n      .join(',')}}>`;\r\n  return schema;\r\n}\r\n\r\n/**\r\n * Create an Expandable Object type schema.\r\n *\r\n * The object schema allows additional properties during mapping and unmapping. The\r\n * additional properties are copied over as is.\r\n */\r\nexport function expandoObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): ObjectSchema<V, T> {\r\n  return internalObject(objectSchema, true, true);\r\n}\r\n\r\n/**\r\n * Create an Object Type schema.\r\n *\r\n * The Object schema allows additional properties during mapping and unmapping\r\n * but discards them.\r\n */\r\nexport function object<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): StrictObjectSchema<V, T> {\r\n  const schema = internalObject(objectSchema, true, false);\r\n  schema.type = () =>\r\n    `Object<{${Object.keys(objectSchema)\r\n      .map(objectKeyEncode)\r\n      .join(',')}}>`;\r\n  return schema;\r\n}\r\n\r\n/**\r\n * Create a strict-object schema that extends an existing schema.\r\n */\r\nexport function extendStrictObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: StrictObjectSchema<V, T>,\r\n  objectSchema: B\r\n): StrictObjectSchema<string, T & B> {\r\n  return strictObject({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Create an object schema that extends an existing schema.\r\n */\r\nexport function extendExpandoObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: ObjectSchema<V, T>,\r\n  objectSchema: B\r\n): ObjectSchema<string, T & B> {\r\n  return expandoObject({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Create an Object schema that extends an existing object schema.\r\n */\r\nexport function extendObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: StrictObjectSchema<V, T>,\r\n  objectSchema: B\r\n): StrictObjectSchema<string, T & B> {\r\n  return object({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Internal utility to create object schema with different options.\r\n */\r\nfunction internalObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  objectSchema: T,\r\n  skipValidateAdditionalProps: boolean,\r\n  mapAdditionalProps: boolean\r\n): StrictObjectSchema<V, T> {\r\n  const keys = Object.keys(objectSchema);\r\n  const reverseObjectSchema = createReverseObjectSchema<T>(objectSchema);\r\n  const xmlMappingInfo = getXmlPropMappingForObjectSchema(objectSchema);\r\n  const xmlObjectSchema = createXmlObjectSchema(objectSchema);\r\n  const reverseXmlObjectSchema = createReverseXmlObjectSchema(xmlObjectSchema);\r\n  return {\r\n    type: () => `Object<{${keys.map(objectKeyEncode).join(',')},...}>`,\r\n    validateBeforeMap: validateObject(\r\n      objectSchema,\r\n      'validateBeforeMap',\r\n      skipValidateAdditionalProps\r\n    ),\r\n    validateBeforeUnmap: validateObject(\r\n      reverseObjectSchema,\r\n      'validateBeforeUnmap',\r\n      skipValidateAdditionalProps\r\n    ),\r\n    map: mapObject(objectSchema, 'map', mapAdditionalProps),\r\n    unmap: mapObject(reverseObjectSchema, 'unmap', mapAdditionalProps),\r\n    validateBeforeMapXml: validateObjectBeforeMapXml(\r\n      objectSchema,\r\n      xmlMappingInfo,\r\n      skipValidateAdditionalProps\r\n    ),\r\n    mapXml: mapObjectFromXml(xmlObjectSchema, mapAdditionalProps),\r\n    unmapXml: unmapObjectToXml(reverseXmlObjectSchema, mapAdditionalProps),\r\n    objectSchema: objectSchema,\r\n  };\r\n}\r\n\r\nfunction validateObjectBeforeMapXml(\r\n  objectSchema: Record<string, [string, Schema<any>, ObjectXmlOptions?]>,\r\n  xmlMappingInfo: ReturnType<typeof getXmlPropMappingForObjectSchema>,\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  const { elementsToProps, attributesToProps } = xmlMappingInfo;\r\n  return (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ): SchemaValidationError[] => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    const valueObject = value as {\r\n      $?: Record<string, unknown>;\r\n      [key: string]: unknown;\r\n    };\r\n    let { $: attributes, ...elements } = valueObject;\r\n    attributes = attributes ?? {};\r\n\r\n    // Validate all known elements and attributes using the schema\r\n    return [\r\n      ...validateValueObject({\r\n        validationMethod: 'validateBeforeMapXml',\r\n        propTypeName: 'child elements',\r\n        propTypePrefix: 'element',\r\n        valueTypeName: 'element',\r\n        propMapping: elementsToProps,\r\n        objectSchema,\r\n        valueObject: elements,\r\n        ctxt,\r\n        allowAdditionalProperties,\r\n      }),\r\n      ...validateValueObject({\r\n        validationMethod: 'validateBeforeMapXml',\r\n        propTypeName: 'attributes',\r\n        propTypePrefix: '@',\r\n        valueTypeName: 'element',\r\n        propMapping: attributesToProps,\r\n        objectSchema,\r\n        valueObject: attributes,\r\n        ctxt,\r\n        allowAdditionalProperties,\r\n      }),\r\n    ];\r\n  };\r\n}\r\n\r\nfunction mapObjectFromXml(\r\n  xmlObjectSchema: XmlObjectSchema,\r\n  allowAdditionalProps: boolean\r\n) {\r\n  const { elementsSchema, attributesSchema } = xmlObjectSchema;\r\n  const mapElements = mapObject(elementsSchema, 'mapXml', allowAdditionalProps);\r\n  const mapAttributes = mapObject(\r\n    attributesSchema,\r\n    'mapXml',\r\n    false // Always false; additional attributes are handled differently below.\r\n  );\r\n\r\n  // These are later used to omit know attribute props from the attributes object\r\n  // so that the remaining props can be copied over as additional props.\r\n  const attributeKeys = objectEntries(attributesSchema).map(\r\n    ([_, [name]]) => name\r\n  );\r\n\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    const valueObject = value as {\r\n      $?: Record<string, unknown>;\r\n      [key: string]: unknown;\r\n    };\r\n    let { $: attributes, ...elements } = valueObject;\r\n    attributes = attributes ?? {};\r\n\r\n    const output: Record<string, unknown> = {\r\n      ...mapAttributes(attributes, ctxt),\r\n      ...mapElements(elements, ctxt),\r\n    };\r\n\r\n    if (allowAdditionalProps) {\r\n      // Omit known attributes and copy the rest as additional attributes.\r\n      const additionalAttrs = omitKeysFromObject(attributes, attributeKeys);\r\n      if (Object.keys(additionalAttrs).length > 0) {\r\n        // These additional attrs are set in the '$' property by convention.\r\n        output['$'] = additionalAttrs;\r\n      }\r\n    }\r\n\r\n    return output;\r\n  };\r\n}\r\n\r\nfunction unmapObjectToXml(\r\n  xmlObjectSchema: XmlObjectSchema,\r\n  allowAdditionalProps: boolean\r\n) {\r\n  const { elementsSchema, attributesSchema } = xmlObjectSchema;\r\n  const mapElements = mapObject(\r\n    elementsSchema,\r\n    'unmapXml',\r\n    allowAdditionalProps\r\n  );\r\n  const mapAttributes = mapObject(\r\n    attributesSchema,\r\n    'unmapXml',\r\n    false // Always false so that element props are not copied during mapping\r\n  );\r\n\r\n  // These are later used to omit attribute props from the value object so that they\r\n  // do not get mapped during element mapping, if the allowAdditionalProps is true.\r\n  const attributeKeys = objectEntries(attributesSchema).map(\r\n    ([_, [name]]) => name\r\n  );\r\n\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    // Get additional attributes which are set in the '$' property by convention\r\n    const { $: attributes, ...rest } = value as {\r\n      $?: unknown;\r\n      [key: string]: unknown;\r\n    };\r\n\r\n    // Ensure 'attributes' is an object and non-null\r\n    const additionalAttributes =\r\n      typeof attributes === 'object' &&\r\n      attributes !== null &&\r\n      allowAdditionalProps\r\n        ? attributes\r\n        : {};\r\n\r\n    return {\r\n      ...mapElements(omitKeysFromObject(rest, attributeKeys), ctxt),\r\n      $: { ...additionalAttributes, ...mapAttributes(value, ctxt) },\r\n    };\r\n  };\r\n}\r\n\r\nfunction validateValueObject({\r\n  validationMethod,\r\n  propTypeName,\r\n  propTypePrefix,\r\n  valueTypeName,\r\n  propMapping,\r\n  objectSchema,\r\n  valueObject,\r\n  ctxt,\r\n  allowAdditionalProperties,\r\n}: {\r\n  validationMethod:\r\n    | 'validateBeforeMap'\r\n    | 'validateBeforeUnmap'\r\n    | 'validateBeforeMapXml';\r\n  propTypeName: string;\r\n  propTypePrefix: string;\r\n  valueTypeName: string;\r\n  propMapping: Record<string, string>;\r\n  objectSchema: AnyObjectSchema;\r\n  valueObject: { [key: string]: unknown };\r\n  ctxt: SchemaContextCreator;\r\n  allowAdditionalProperties: boolean;\r\n}) {\r\n  const errors: SchemaValidationError[] = [];\r\n  const missingProps: Set<string> = new Set();\r\n  const unknownProps: Set<string> = new Set(Object.keys(valueObject));\r\n\r\n  // Validate all known properties using the schema\r\n  for (const key in propMapping) {\r\n    const propName = propMapping[key];\r\n    const schema = objectSchema[propName][1];\r\n    unknownProps.delete(key);\r\n    if (key in valueObject) {\r\n      errors.push(\r\n        ...schema[validationMethod](\r\n          valueObject[key],\r\n          ctxt.createChild(propTypePrefix + key, valueObject[key], schema)\r\n        )\r\n      );\r\n    } else if (schema.type().indexOf('Optional<') !== 0) {\r\n      // Add to missing keys if it is not an optional property\r\n      missingProps.add(key);\r\n    }\r\n  }\r\n\r\n  // Create validation error for unknown properties encountered\r\n  const unknownPropsArray = Array.from(unknownProps);\r\n  if (unknownPropsArray.length > 0 && !allowAdditionalProperties) {\r\n    errors.push(\r\n      ...ctxt.fail(\r\n        `Some unknown ${propTypeName} were found in the ${valueTypeName}: ${unknownPropsArray\r\n          .map(literalToString)\r\n          .join(', ')}.`\r\n      )\r\n    );\r\n  }\r\n\r\n  // Create validation error for missing required properties\r\n  const missingPropsArray = Array.from(missingProps);\r\n  if (missingPropsArray.length > 0) {\r\n    errors.push(\r\n      ...ctxt.fail(\r\n        `Some ${propTypeName} are missing in the ${valueTypeName}: ${missingPropsArray\r\n          .map(literalToString)\r\n          .join(', ')}.`\r\n      )\r\n    );\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\nfunction validateObject(\r\n  objectSchema: AnyObjectSchema,\r\n  validationMethod:\r\n    | 'validateBeforeMap'\r\n    | 'validateBeforeUnmap'\r\n    | 'validateBeforeMapXml',\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  const propsMapping = getPropMappingForObjectSchema(objectSchema);\r\n  return (value: unknown, ctxt: SchemaContextCreator) => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    return validateValueObject({\r\n      validationMethod,\r\n      propTypeName: 'properties',\r\n      propTypePrefix: '',\r\n      valueTypeName: 'object',\r\n      propMapping: propsMapping,\r\n      objectSchema,\r\n      valueObject: value as Record<string, unknown>,\r\n      ctxt,\r\n      allowAdditionalProperties,\r\n    });\r\n  };\r\n}\r\n\r\nfunction mapObject<T extends AnyObjectSchema>(\r\n  objectSchema: T,\r\n  mappingFn: 'map' | 'unmap' | 'mapXml' | 'unmapXml',\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    const output: Record<string, unknown> = {};\r\n    const objectValue = value as Record<string, any>;\r\n    /** Properties seen in the object but not in the schema */\r\n    const unknownKeys = new Set(Object.keys(objectValue));\r\n\r\n    // Map known properties using the schema\r\n    for (const key in objectSchema) {\r\n      /* istanbul ignore else */\r\n      if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n        const element = objectSchema[key];\r\n        const propName = element[0];\r\n        const propValue = objectValue[propName];\r\n        unknownKeys.delete(propName);\r\n\r\n        // Skip mapping for optional properties to avoid creating properties with value 'undefined'\r\n        if (\r\n          element[1].type().indexOf('Optional<') !== 0 ||\r\n          propValue !== undefined\r\n        ) {\r\n          output[key] = element[1][mappingFn](\r\n            propValue,\r\n            ctxt.createChild(propName, propValue, element[1])\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Copy unknown properties over if additional properties flag is set\r\n    if (allowAdditionalProperties) {\r\n      unknownKeys.forEach(unknownKey => {\r\n        output[unknownKey] = objectValue[unknownKey];\r\n      });\r\n    }\r\n    return output;\r\n  };\r\n}\r\n\r\nfunction getXmlPropMappingForObjectSchema(objectSchema: AnyObjectSchema) {\r\n  const elementsToProps: Record<string, string> = {};\r\n  const attributesToProps: Record<string, string> = {};\r\n\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const [propName, , xmlOptions] = objectSchema[key];\r\n      if (xmlOptions?.isAttr === true) {\r\n        attributesToProps[xmlOptions.xmlName ?? propName] = key;\r\n      } else {\r\n        elementsToProps[xmlOptions?.xmlName ?? propName] = key;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { elementsToProps, attributesToProps };\r\n}\r\n\r\nfunction getPropMappingForObjectSchema(\r\n  objectSchema: AnyObjectSchema\r\n): Record<string, string> {\r\n  const propsMapping: Record<string, string> = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const propDef = objectSchema[key];\r\n      propsMapping[propDef[0]] = key;\r\n    }\r\n  }\r\n  return propsMapping;\r\n}\r\n\r\nfunction createReverseObjectSchema<T extends AnyObjectSchema>(\r\n  objectSchema: T\r\n): AnyObjectSchema {\r\n  const reverseObjectSchema: AnyObjectSchema = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const element = objectSchema[key];\r\n      reverseObjectSchema[element[0]] = [key, element[1], element[2]];\r\n    }\r\n  }\r\n  return reverseObjectSchema;\r\n}\r\n\r\ntype XmlObjectSchema = {\r\n  elementsSchema: AnyObjectSchema;\r\n  attributesSchema: AnyObjectSchema;\r\n};\r\n\r\nfunction createXmlObjectSchema(objectSchema: AnyObjectSchema): XmlObjectSchema {\r\n  const elementsSchema: AnyObjectSchema = {};\r\n  const attributesSchema: AnyObjectSchema = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const element = objectSchema[key];\r\n      const [serializedName, schema, xmlOptions] = element;\r\n      const xmlObjectSchema = xmlOptions?.isAttr\r\n        ? attributesSchema\r\n        : elementsSchema;\r\n      xmlObjectSchema[key] = [\r\n        xmlOptions?.xmlName ?? serializedName,\r\n        schema,\r\n        xmlOptions,\r\n      ];\r\n    }\r\n  }\r\n  return { elementsSchema, attributesSchema };\r\n}\r\n\r\nfunction createReverseXmlObjectSchema(\r\n  xmlObjectSchema: XmlObjectSchema\r\n): XmlObjectSchema {\r\n  return {\r\n    attributesSchema: createReverseObjectSchema(\r\n      xmlObjectSchema.attributesSchema\r\n    ),\r\n    elementsSchema: createReverseObjectSchema(xmlObjectSchema.elementsSchema),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport { arrayEntries } from '../utils';\r\n\r\nexport interface ArrayXmlOptions {\r\n  xmlItemName: string;\r\n}\r\n\r\n/**\r\n * Create an array schema.\r\n *\r\n * The array must be a homogenous array confirming to the itemsSchema. Each item\r\n * will be mapped/unmapped using the itemsSchema.\r\n */\r\nexport function array<T, S>(\r\n  itemsSchema: Schema<T, S>,\r\n  xmlOptions?: ArrayXmlOptions\r\n): Schema<T[], S[]> {\r\n  let arraySchema: Schema<T[], S[]>;\r\n  arraySchema = {\r\n    type: () => `Array<${itemsSchema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      Array.isArray(value)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(value),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeMap(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail(),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      Array.isArray(value)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(value),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeUnmap(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail(),\r\n    map: (value, ctxt) =>\r\n      ctxt.mapChildren(arrayEntries(value), itemsSchema, (v, childCtxt) =>\r\n        itemsSchema.map(v[1], childCtxt)\r\n      ),\r\n    unmap: (value, ctxt) =>\r\n      ctxt.mapChildren(arrayEntries(value), itemsSchema, (v, childCtxt) =>\r\n        itemsSchema.unmap(v[1], childCtxt)\r\n      ),\r\n    mapXml: (value, ctxt) => {\r\n      let items = value;\r\n      if (xmlOptions?.xmlItemName) {\r\n        items = value[xmlOptions.xmlItemName];\r\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\r\n      }\r\n      return ctxt.mapChildren(\r\n        arrayEntries(items as any[]),\r\n        itemsSchema,\r\n        (v, childCtxt) => itemsSchema.mapXml(v[1], childCtxt)\r\n      );\r\n    },\r\n    unmapXml: (value, ctxt) => {\r\n      const items = ctxt.mapChildren(\r\n        arrayEntries(value),\r\n        itemsSchema,\r\n        (v, childCtxt) => itemsSchema.unmapXml(v[1], childCtxt)\r\n      );\r\n      if (xmlOptions?.xmlItemName) {\r\n        return { [xmlOptions.xmlItemName]: items };\r\n      } else {\r\n        return items;\r\n      }\r\n    },\r\n    validateBeforeMapXml: (value, ctxt) => {\r\n      let items = value;\r\n      if (xmlOptions?.xmlItemName) {\r\n        const errorMessage = `Expected array to be wrapped with XML element ${xmlOptions.xmlItemName}.`;\r\n        if (\r\n          typeof value !== 'object' ||\r\n          value === null ||\r\n          !(xmlOptions.xmlItemName in value)\r\n        ) {\r\n          return ctxt.fail(errorMessage);\r\n        }\r\n        items = (value as Record<string, unknown>)[xmlOptions.xmlItemName];\r\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\r\n      }\r\n\r\n      return Array.isArray(items)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(items),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeMapXml(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail();\r\n    },\r\n  };\r\n  return arraySchema;\r\n}\r\n","import { Schema, SchemaMappedType, SchemaType } from '../schema';\r\nimport { objectEntries } from '../utils';\r\nimport { ObjectXmlOptions } from './object';\r\n\r\nexport function discriminatedObject<\r\n  TSchema extends Schema<any, any>,\r\n  TDiscrimProp extends keyof SchemaType<TSchema>,\r\n  TDiscrimMappedProp extends keyof SchemaMappedType<TSchema>,\r\n  TDiscrimMap extends Record<string, TSchema>\r\n>(\r\n  discriminatorMappedPropName: TDiscrimMappedProp,\r\n  discriminatorPropName: TDiscrimProp,\r\n  discriminatorMap: TDiscrimMap,\r\n  defaultDiscriminator: keyof TDiscrimMap,\r\n  xmlOptions?: ObjectXmlOptions\r\n): Schema<any, any> {\r\n  const schemaSelector = (\r\n    value: unknown,\r\n    discriminatorProp: string | TDiscrimProp | TDiscrimMappedProp,\r\n    isAttr: boolean = false\r\n  ) => {\r\n    if (\r\n      typeof value === 'object' &&\r\n      value !== null &&\r\n      ((isAttr && xmlObjectHasAttribute(value, discriminatorProp as string)) ||\r\n        (!isAttr && (discriminatorProp as string) in value))\r\n    ) {\r\n      const discriminatorValue = isAttr\r\n        ? (value as { $: Record<string, unknown> })['$'][\r\n            discriminatorProp as string\r\n          ]\r\n        : (value as Record<typeof discriminatorProp, unknown>)[\r\n            discriminatorProp\r\n          ];\r\n      if (\r\n        typeof discriminatorValue === 'string' &&\r\n        discriminatorValue in discriminatorMap\r\n      ) {\r\n        return discriminatorMap[discriminatorValue];\r\n      }\r\n    }\r\n    return discriminatorMap[defaultDiscriminator];\r\n  };\r\n  return {\r\n    type: () =>\r\n      `DiscriminatedUnion<${discriminatorPropName},[${objectEntries(\r\n        discriminatorMap\r\n      )\r\n        .map(([_, v]) => v.type)\r\n        .join(',')}]>`,\r\n    map: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorPropName).map(value, ctxt),\r\n    unmap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).unmap(value, ctxt),\r\n    validateBeforeMap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorPropName).validateBeforeMap(\r\n        value,\r\n        ctxt\r\n      ),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).validateBeforeUnmap(\r\n        value,\r\n        ctxt\r\n      ),\r\n    mapXml: (value, ctxt) =>\r\n      schemaSelector(\r\n        value,\r\n        xmlOptions?.xmlName ?? discriminatorPropName,\r\n        xmlOptions?.isAttr\r\n      ).mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).unmapXml(value, ctxt),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      schemaSelector(\r\n        value,\r\n        xmlOptions?.xmlName ?? discriminatorPropName,\r\n        xmlOptions?.isAttr\r\n      ).validateBeforeMapXml(value, ctxt),\r\n  };\r\n}\r\n\r\nfunction xmlObjectHasAttribute(value: object, prop: string): boolean {\r\n  return (\r\n    '$' in value &&\r\n    typeof (value as { $: unknown })['$'] === 'object' &&\r\n    (prop as string) in (value as { $: Record<string, unknown> })['$']\r\n  );\r\n}\r\n","import { Schema } from '../schema';\r\nimport { once } from '../utils';\r\n\r\n/**\r\n * Create a schema that lazily delegates to the given schema.\r\n */\r\nexport function lazy<T, V>(schemaFn: () => Schema<T, V>): Schema<T, V> {\r\n  const getSchema = once(schemaFn); // Memoize schema\r\n  return {\r\n    type: () => `Lazy<${getSchema().type()}>`,\r\n    map: (...args) => getSchema().map(...args),\r\n    unmap: (...args) => getSchema().unmap(...args),\r\n    validateBeforeMap: (...args) => getSchema().validateBeforeMap(...args),\r\n    validateBeforeUnmap: (...args) => getSchema().validateBeforeUnmap(...args),\r\n    mapXml: (...args) => getSchema().mapXml(...args),\r\n    unmapXml: (...args) => getSchema().unmapXml(...args),\r\n    validateBeforeMapXml: (...args) =>\r\n      getSchema().validateBeforeMapXml(...args),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport { createSymmetricSchema, literalToString, toValidator } from '../utils';\r\n\r\n/**\r\n * Create a literal schema.\r\n *\r\n * This schema always unmaps/maps to the constant value provided in the schema,\r\n * regardless of the value being mapped/unmapped. The validation always passes.\r\n */\r\nexport function literal<T extends boolean>(literalValue: T): Schema<T, T>;\r\nexport function literal<T extends number>(literalValue: T): Schema<T, T>;\r\nexport function literal<T extends string>(literalValue: T): Schema<T, T>;\r\nexport function literal<T>(literalValue: T): Schema<T, T>;\r\nexport function literal<T>(literalValue: T): Schema<T, T> {\r\n  const validate = (value: unknown): value is T => literalValue === value;\r\n  const map = () => literalValue;\r\n  return createSymmetricSchema({\r\n    type: `Literal<${literalToString(literalValue)}>`,\r\n    validate: toValidator(validate),\r\n    map: map,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\n\r\n/**\r\n * Creates a nullable schema.\r\n *\r\n * The nullable schema allows null values or the values allowed by the given\r\n * 'schema'.\r\n */\r\nexport function nullable<T, S>(\r\n  schema: Schema<T, S>\r\n): Schema<T | null, S | null> {\r\n  return {\r\n    type: () => `Nullable<${schema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeMap(value, ctxt),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeUnmap(value, ctxt),\r\n    map: (value, ctxt) => (value === null ? null : schema.map(value, ctxt)),\r\n    unmap: (value, ctxt) => (value === null ? null : schema.unmap(value, ctxt)),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeMapXml(value, ctxt),\r\n    mapXml: (value, ctxt) =>\r\n      value === null ? null : schema.mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      value === null ? null : schema.unmapXml(value, ctxt),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  coerceNumericStringToNumber,\r\n  createSymmetricSchema,\r\n  isNumericString,\r\n  toValidator,\r\n} from '../utils';\r\n\r\nfunction createEnumChecker<T extends string, TEnumValue extends number>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n) {\r\n  const enumValues = Object.values(enumVariable);\r\n  return (value: unknown): value is TEnumValue =>\r\n    isNumericString(value) &&\r\n    enumValues.includes(coerceNumericStringToNumber(value));\r\n}\r\n\r\n/**\r\n * Create a schema for a number enumeration.\r\n */\r\nexport function numberEnum<T extends string, TEnumValue extends number>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n): Schema<TEnumValue, TEnumValue> {\r\n  const validate = toValidator(createEnumChecker(enumVariable));\r\n\r\n  return createSymmetricSchema({\r\n    type: `Enum<${Object.values(enumVariable)\r\n      .filter(v => typeof v === 'number')\r\n      .join(',')}>`,\r\n    map: coerceNumericStringToNumber as (value: unknown) => TEnumValue,\r\n    validate: validate,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\n\r\n/**\r\n * Create an optional schema.\r\n *\r\n * The optional schema allows 'undefined' or the values allowed by the given\r\n * 'schema'.\r\n */\r\nexport function optional<T, S>(\r\n  schema: Schema<T, S>\r\n): Schema<T | undefined, S | undefined> {\r\n  return {\r\n    type: () => `Optional<${schema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeMap(value, ctxt),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeUnmap(value, ctxt),\r\n    map: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.map(value, ctxt),\r\n    unmap: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.unmap(value, ctxt),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeMapXml(value, ctxt),\r\n    mapXml: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.unmapXml(value, ctxt),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  toValidator,\r\n  createSymmetricSchema,\r\n  identityFn,\r\n  literalToString,\r\n} from '../utils';\r\n\r\nfunction createEnumChecker<T extends string, TEnumValue extends string>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n) {\r\n  const enumValues = Object.values(enumVariable);\r\n  return (value: unknown): value is TEnumValue =>\r\n    typeof value === 'string' && enumValues.includes(value);\r\n}\r\n\r\n/**\r\n * Create a schema for a string enumeration.\r\n */\r\nexport function stringEnum<T extends string, TEnumValue extends string>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n): Schema<TEnumValue, TEnumValue> {\r\n  const validate = toValidator(createEnumChecker(enumVariable));\r\n\r\n  return createSymmetricSchema({\r\n    type: `Enum<${Object.values(enumVariable)\r\n      .map(literalToString)\r\n      .join(',')}>`,\r\n    map: identityFn,\r\n    validate: validate,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\nimport { createSymmetricSchema, identityFn } from '../utils';\r\n\r\n/**\r\n * Create an unknown schema.\r\n *\r\n * The unknown schema allows any value.\r\n */\r\nexport function unknown(): Schema<unknown, unknown> {\r\n  return createSymmetricSchema({\r\n    type: 'unknown',\r\n    validate: () => [],\r\n    map: identityFn,\r\n  });\r\n}\r\n"],"names":["arrayEntries","arr","entries","index","length","push","objectEntries","obj","ownProps","Object","keys","i","resArray","Array","literalToString","value","replace","identityFn","toValidator","fn","ctxt","fail","createSymmetricSchema","schema","basicSchema","type","validateBeforeMap","validate","validateBeforeUnmap","map","unmap","validateBeforeMapXml","mapXml","unmapXml","isNumericString","isNaN","coerceNumericStringToNumber","omitKeysFromObject","object","keysToOmit","omitSet","Set","output","key","prototype","hasOwnProperty","call","has","objectKeyEncode","indexOf","createNewSchemaContext","branch","path","createSchemaContextCreator","currentContext","createChildContext","childSchema","mapChildren","items","itemSchema","mapper","item","createChild","flatmapChildren","flatten","message","createErrorMessage","JSON","stringify","toString","join","isValidStringValue","isValidBooleanValue","shouldDefault","defaultValue","dict","validateFn","v","childCtxt","args","propValue","strictObject","objectSchema","internalObject","expandoObject","skipValidateAdditionalProps","mapAdditionalProps","reverseObjectSchema","createReverseObjectSchema","xmlMappingInfo","elementsToProps","attributesToProps","propName","xmlOptions","isAttr","xmlName","getXmlPropMappingForObjectSchema","xmlObjectSchema","elementsSchema","attributesSchema","element","createXmlObjectSchema","reverseXmlObjectSchema","createReverseXmlObjectSchema","validateObject","mapObject","validateObjectBeforeMapXml","mapObjectFromXml","unmapObjectToXml","allowAdditionalProperties","attributes","$","elements","validateValueObject","validationMethod","propTypeName","propTypePrefix","valueTypeName","propMapping","valueObject","allowAdditionalProps","mapElements","mapAttributes","attributeKeys","additionalAttrs","rest","additionalAttributes","errors","missingProps","unknownProps","add","unknownPropsArray","from","missingPropsArray","propsMapping","getPropMappingForObjectSchema","mappingFn","objectValue","unknownKeys","undefined","forEach","unknownKey","itemsSchema","isArray","xmlItemName","dictSchema","modifiedSchema","entry","_","dictObj","discriminatorMappedPropName","discriminatorPropName","discriminatorMap","defaultDiscriminator","schemaSelector","discriminatorProp","prop","xmlObjectHasAttribute","discriminatorValue","parentObjectSchema","schemaFn","func","memo","ran","getSchema","apply","this","literalValue","enumVariable","enumValues","values","includes","createEnumChecker","filter","contextCreator","validationResult","result"],"mappings":"+lBAMgBA,EAAgBC,WACxBC,EAAyB,GACtBC,EAAQ,EAAGA,EAAQF,EAAIG,OAAQD,IAEtCD,EAAQG,KAAK,CAACF,EADEF,EAAIE,YAGfD,WAGOI,EACdC,WAEIC,EAAWC,OAAOC,KAAKH,GACzBI,EAAIH,EAASJ,OACbQ,EAAW,IAAIC,MAAMF,GAChBA,KAAKC,EAASD,GAAK,CAACH,EAASG,GAAIJ,EAAIC,EAASG,YAE9CC,WAGOE,EAAgBC,SACN,iBAAVA,MACNA,EAAMC,QAAQ,KAAM,YACrBD,WAGOE,EAAcF,UACrBA,WAGOG,EACdC,UAEO,SAACJ,EAAOK,UAAUD,EAAGJ,GAAS,GAAKK,EAAKC,iBAkBjCC,EACdC,eA0B+BC,EAxBN,CACvBC,KAAM,kBAAMF,EAAOE,MACnBC,kBAAmBH,EAAOI,SAC1BC,oBAAqBL,EAAOI,SAC5BE,IAAKN,EAAOM,IACZC,MAAOP,EAAOM,MAsBdE,qBAAsBP,EAAYI,oBAClCI,OAAQR,EAAYK,IACpBI,SAAUT,EAAYM,QAL1B,IAAiCN,WASjBU,EAAgBnB,SAEX,iBAAVA,GACW,iBAAVA,IAAuBoB,MAAMpB,YAIzBqB,EAA4BrB,SAClB,iBAAVA,EAAqBA,GAASA,WAmB9BsB,EACdC,EACAC,OAEMC,EAAU,IAAIC,IAAIF,GAClBG,EAAkC,OACnC,IAAMC,KAAOL,EAEd7B,OAAOmC,UAAUC,eAAeC,KAAKR,EAAQK,KAC5CH,EAAQO,IAAIJ,KAEbD,EAAOC,GAAOL,EAAOK,WAGlBD,WAGOM,EAAgBL,UACD,IAAtBA,EAAIM,QAAQ,KAAcnC,EAAgB6B,GAAOA,EC2C1D,SAASO,EAAuBnC,EAAgBU,SACvC,CACLV,MAAAA,EACAU,KAAAA,EACA0B,OAAQ,CAACpC,GACTqC,KAAM,IAOV,SAASC,EACPC,OAEMC,EAA0D,SAC9DZ,EACA5B,EACAyC,UAEAH,EAA2B,CACzBtC,MAAAA,EACAU,KAAM+B,EAAY/B,OAClB0B,iBAAYG,EAAeH,QAAQpC,IACnCqC,eAAUE,EAAeF,MAAMT,OAG7Bc,EAAmD,SACvDC,EACAC,EACAC,UAEAF,EAAM7B,KAAI,SAAAgC,UACRD,EAAOC,EAAMN,EAAmBM,EAAK,GAAIA,EAAK,GAAIF,oBAIjDL,GACHQ,YAAaP,EACbQ,gBAAiB,kBAAaC,EAAQP,4BACtCA,YAAaA,EACbpC,KAAM,SAAA4C,SAAW,MAEVX,GACHW,QAASC,EAAmBZ,EAAgBW,SAMpD,SAASC,EAAmB9C,EAAqB6C,gBAC/CA,YACGA,sCAEG7C,EAAKK,4BACgBL,EAAKL,YAH9B,oBAKkBoD,KAAKC,UAAUhD,EAAKL,0BACnBK,EAAKL,MANxB,sBAOqBK,EAAKK,SAExBL,EAAKgC,KAAKhD,OAAS,IAIrB6D,cAHmB7C,EAAKgC,KACrBvB,KAAI,SAAAd,UAASiC,EAAgBjC,EAAMsD,eACnCC,KAAK,QAIHL,EChPT,SAASM,EAAmBxD,SACF,iBAAVA,EAqBhB,SAASyD,EAAoBzD,SAER,kBAAVA,GACW,iBAAVA,IAAiC,SAAVA,GAA8B,UAAVA,GCAvD,SAAS0D,EAA8B1D,EAAU2D,UACxC3D,MAAAA,GAAyCA,IAAU2D,WC3B5CC,EACdhB,OAEMhC,EAAW,SACfiD,EAIA7D,EACAK,SAEqB,iBAAVL,GAAgC,OAAVA,EACxBK,EAAKC,OAGPD,EAAK2C,gBACVzD,EAFkBS,GAGlB4C,GACA,SAACkB,EAAGC,UAAcnB,EAAWiB,GAAYC,EAAE,GAAIC,aAI5C,CACLrD,KAAM,kCAAuBkC,EAAWlC,YACxCC,kBAAmB,sCAAIqD,2BAAAA,yBAASpD,gBAAS,4BAAwBoD,KACjEnD,oBAAqB,sCAAImD,2BAAAA,yBAASpD,gBAAS,8BAA0BoD,KACrElD,IAAK,SAACd,EAAOK,OACLsB,EAA4B,OAC7B,IAAMC,KAAO5B,KAEZN,OAAOmC,UAAUC,eAAeC,KAAK/B,EAAO4B,GAAM,KAC9CqC,EAAYjE,EAAM4B,GACxBD,EAAOC,GAAOgB,EAAW9B,IACvBmD,EACA5D,EAAK0C,YAAYnB,EAAKqC,EAAWrB,WAIhCjB,GAETZ,MAAO,SAACf,EAAOK,OACPsB,EAA4B,OAC7B,IAAMC,KAAO5B,KAEZN,OAAOmC,UAAUC,eAAeC,KAAK/B,EAAO4B,GAAM,KAC9CqC,EAAYjE,EAAM4B,GACxBD,EAAOC,GAAOgB,EAAW7B,MACvBkD,EACA5D,EAAK0C,YAAYnB,EAAKqC,EAAWrB,WAIhCjB,GAETX,qBAAsB,sCAAIgD,2BAAAA,yBACxBpD,gBAAS,+BAA2BoD,KACtC/C,OAAQ,SAACjB,EAAOK,OACRsB,EAA4B,OAC7B,IAAMC,KAAO5B,KAEZN,OAAOmC,UAAUC,eAAeC,KAAK/B,EAAO4B,GAAM,KAC9CqC,EAAYjE,EAAM4B,GACxBD,EAAOC,GAAOgB,EAAW3B,OACvBgD,EACA5D,EAAK0C,YAAYnB,EAAKqC,EAAWrB,WAIhCjB,GAETT,SAAU,SAAClB,EAAOK,OACVsB,EAA4B,OAC7B,IAAMC,KAAO5B,KAEZN,OAAOmC,UAAUC,eAAeC,KAAK/B,EAAO4B,GAAM,KAC9CqC,EAAYjE,EAAM4B,GACxBD,EAAOC,GAAOgB,EAAW1B,SACvB+C,EACA5D,EAAK0C,YAAYnB,EAAKqC,EAAWrB,WAIhCjB,aCvBGuC,EAGdC,OACM3D,EAAS4D,EAAeD,GAAc,GAAO,UACnD3D,EAAOE,KAAO,kCACKhB,OAAOC,KAAKwE,GAC1BrD,IAAImB,GACJsB,KAAK,WACH/C,WASO6D,EAGdF,UACOC,EAAeD,GAAc,GAAM,YAS5B5C,EAGd4C,OACM3D,EAAS4D,EAAeD,GAAc,GAAM,UAClD3D,EAAOE,KAAO,4BACDhB,OAAOC,KAAKwE,GACpBrD,IAAImB,GACJsB,KAAK,WACH/C,EAmDT,SAAS4D,EAIPD,EACAG,EACAC,OAEM5E,EAAOD,OAAOC,KAAKwE,GACnBK,EAAsBC,EAA6BN,GACnDO,EAmTR,SAA0CP,OAClCQ,EAA0C,GAC1CC,EAA4C,OAE7C,IAAMhD,KAAOuC,KAEZzE,OAAOmC,UAAUC,eAAeC,KAAKoC,EAAcvC,GAAM,WAC1BuC,EAAavC,GAAvCiD,OAAYC,QACQ,WAAvBA,SAAAA,EAAYC,QACdH,WAAkBE,EAAWE,WAAWH,GAAYjD,EAEpD+C,iBAAgBG,SAAAA,EAAYE,WAAWH,GAAYjD,QAKlD,CAAE+C,gBAAAA,EAAiBC,kBAAAA,GAnUHK,CAAiCd,GAClDe,EAsWR,SAA+Bf,OACvBgB,EAAkC,GAClCC,EAAoC,OACrC,IAAMxD,KAAOuC,KAEZzE,OAAOmC,UAAUC,eAAeC,KAAKoC,EAAcvC,GAAM,OACrDyD,EAAUlB,EAAavC,GACEkD,EAAcO,aACrBP,SAAAA,EAAYC,QAChCK,EACAD,GACYvD,GAAO,gBACrBkD,SAAAA,EAAYE,WAL+BK,KAAAA,KAO3CP,SAIC,CAAEK,eAAAA,EAAgBC,iBAAAA,GAxXDE,CAAsBnB,GACxCoB,EA0XR,SACEL,SAEO,CACLE,iBAAkBX,EAChBS,EAAgBE,kBAElBD,eAAgBV,EAA0BS,EAAgBC,iBAjY7BK,CAA6BN,SACrD,CACLxE,KAAM,4BAAiBf,EAAKmB,IAAImB,GAAiBsB,KAAK,eACtD5C,kBAAmB8E,EACjBtB,EACA,oBACAG,GAEFzD,oBAAqB4E,EACnBjB,EACA,sBACAF,GAEFxD,IAAK4E,EAAUvB,EAAc,MAAOI,GACpCxD,MAAO2E,EAAUlB,EAAqB,QAASD,GAC/CvD,qBAAsB2E,EACpBxB,EACAO,EACAJ,GAEFrD,OAAQ2E,EAAiBV,EAAiBX,GAC1CrD,SAAU2E,EAAiBN,EAAwBhB,GACnDJ,aAAcA,GAIlB,SAASwB,EACPxB,EACAO,EACAoB,OAEQnB,EAAuCD,EAAvCC,gBAAiBC,EAAsBF,EAAtBE,yBAClB,SACL5E,EACAK,YAEqB,iBAAVL,GAAgC,OAAVA,SACxBK,EAAKC,WAMLyF,EAJW/F,EAIdgG,EAAkBC,IAJJjG,gBAKpB+F,WAAaA,KAAc,aAItBG,EAAoB,CACrBC,iBAAkB,uBAClBC,aAAc,iBACdC,eAAgB,UAChBC,cAAe,UACfC,YAAa5B,EACbR,aAAAA,EACAqC,YAAaP,EACb5F,KAAAA,EACAyF,0BAAAA,IAECI,EAAoB,CACrBC,iBAAkB,uBAClBC,aAAc,aACdC,eAAgB,IAChBC,cAAe,UACfC,YAAa3B,EACbT,aAAAA,EACAqC,YAAaT,EACb1F,KAAAA,EACAyF,0BAAAA,MAMR,SAASF,EACPV,EACAuB,OAEwBrB,EAAqBF,EAArBE,iBAClBsB,EAAchB,EADyBR,EAArCC,eACsC,SAAUsB,GAClDE,EAAgBjB,EACpBN,EACA,UACA,GAKIwB,EAAgBrH,EAAc6F,GAAkBtE,KACpD,qCAGK,SAACd,EAAgBK,SAKb0F,EAJW/F,EAIdgG,EAAkBC,IAJJjG,SAKpB+F,WAAaA,KAAc,OAErBpE,OACDgF,EAAcZ,EAAY1F,GAC1BqG,EAAYT,EAAU5F,OAGvBoG,EAAsB,KAElBI,EAAkBvF,EAAmByE,EAAYa,GACnDlH,OAAOC,KAAKkH,GAAiBxH,OAAS,IAExCsC,EAAM,EAAQkF,UAIXlF,GAIX,SAASkE,EACPX,EACAuB,OAEwBrB,EAAqBF,EAArBE,iBAClBsB,EAAchB,EADyBR,EAArCC,eAGN,WACAsB,GAEIE,EAAgBjB,EACpBN,EACA,YACA,GAKIwB,EAAgBrH,EAAc6F,GAAkBtE,KACpD,qCAGK,SAACd,EAAgBK,OAEX0F,EAAwB/F,EAA3BgG,EAAkBc,IAAS9G,SAM7B+G,EACkB,iBAAfhB,GACQ,OAAfA,GACAU,EACIV,EACA,eAGDW,EAAYpF,EAAmBwF,EAAMF,GAAgBvG,IACxD2F,OAAQe,EAAyBJ,EAAc3G,EAAOK,OAK5D,SAAS6F,SACPC,IAAAA,iBACAC,IAAAA,aACAC,IAAAA,eACAC,IAAAA,cACAC,IAAAA,YACApC,IAAAA,aACAqC,IAAAA,YACAnG,IAAAA,KACAyF,IAAAA,0BAeMkB,EAAkC,GAClCC,EAA4B,IAAIvF,IAChCwF,EAA4B,IAAIxF,IAAIhC,OAAOC,KAAK6G,QAGjD,IAAM5E,KAAO2E,EAAa,KAEvB/F,EAAS2D,EADEoC,EAAY3E,IACS,GACtCsF,SAAoBtF,GAChBA,KAAO4E,EACTQ,EAAO1H,WAAP0H,EACKxG,EAAO2F,GACRK,EAAY5E,GACZvB,EAAK0C,YAAYsD,EAAiBzE,EAAK4E,EAAY5E,GAAMpB,KAGb,IAAvCA,EAAOE,OAAOwB,QAAQ,cAE/B+E,EAAaE,IAAIvF,OAKfwF,EAAoBtH,MAAMuH,KAAKH,GACjCE,EAAkB/H,OAAS,IAAMyG,GACnCkB,EAAO1H,WAAP0H,EACK3G,EAAKC,qBACU8F,wBAAkCE,OAAkBc,EACjEtG,IAAIf,GACJwD,KAAK,gBAMR+D,EAAoBxH,MAAMuH,KAAKJ,UACjCK,EAAkBjI,OAAS,GAC7B2H,EAAO1H,WAAP0H,EACK3G,EAAKC,aACE8F,yBAAmCE,OAAkBgB,EAC1DxG,IAAIf,GACJwD,KAAK,YAKPyD,EAGT,SAASvB,EACPtB,EACAgC,EAIAL,OAEMyB,EAiFR,SACEpD,OAEMoD,EAAuC,OACxC,IAAM3F,KAAOuC,EAEZzE,OAAOmC,UAAUC,eAAeC,KAAKoC,EAAcvC,KAErD2F,EADgBpD,EAAavC,GACR,IAAMA,UAGxB2F,EA5FcC,CAA8BrD,UAC5C,SAACnE,EAAgBK,SACD,iBAAVL,GAAgC,OAAVA,EACxBK,EAAKC,OAEP4F,EAAoB,CACzBC,iBAAAA,EACAC,aAAc,aACdC,eAAgB,GAChBC,cAAe,SACfC,YAAagB,EACbpD,aAAAA,EACAqC,YAAaxG,EACbK,KAAAA,EACAyF,0BAAAA,KAKN,SAASJ,EACPvB,EACAsD,EACA3B,UAEO,SAAC9F,EAAgBK,OAChBsB,EAAkC,GAClC+F,EAAc1H,EAEd2H,EAAc,IAAIjG,IAAIhC,OAAOC,KAAK+H,QAGnC,IAAM9F,KAAOuC,KAEZzE,OAAOmC,UAAUC,eAAeC,KAAKoC,EAAcvC,GAAM,KACrDyD,EAAUlB,EAAavC,GACvBiD,EAAWQ,EAAQ,GACnBpB,EAAYyD,EAAY7C,GAC9B8C,SAAmB9C,GAI0B,IAA3CQ,EAAQ,GAAG3E,OAAOwB,QAAQ,mBACZ0F,IAAd3D,IAEAtC,EAAOC,GAAOyD,EAAQ,GAAGoC,GACvBxD,EACA5D,EAAK0C,YAAY8B,EAAUZ,EAAWoB,EAAQ,aAOlDS,GACF6B,EAAYE,SAAQ,SAAAC,GAClBnG,EAAOmG,GAAcJ,EAAYI,MAG9BnG,GAqCX,SAAS8C,EACPN,OAEMK,EAAuC,OACxC,IAAM5C,KAAOuC,KAEZzE,OAAOmC,UAAUC,eAAeC,KAAKoC,EAAcvC,GAAM,KACrDyD,EAAUlB,EAAavC,GAC7B4C,EAAoBa,EAAQ,IAAM,CAACzD,EAAKyD,EAAQ,GAAIA,EAAQ,WAGzDb,yBCzfPuD,EACAjD,SAGc,CACZpE,KAAM,0BAAeqH,EAAYrH,YACjCC,kBAAmB,SAACX,EAAOK,UACzBP,MAAMkI,QAAQhI,GACVK,EAAK2C,gBACH/D,EAAae,GACb+H,GACA,SAACjE,EAAGC,UAAcgE,EAAYpH,kBAAkBmD,EAAE,GAAIC,MAExD1D,EAAKC,QACXO,oBAAqB,SAACb,EAAOK,UAC3BP,MAAMkI,QAAQhI,GACVK,EAAK2C,gBACH/D,EAAae,GACb+H,GACA,SAACjE,EAAGC,UAAcgE,EAAYlH,oBAAoBiD,EAAE,GAAIC,MAE1D1D,EAAKC,QACXQ,IAAK,SAACd,EAAOK,UACXA,EAAKqC,YAAYzD,EAAae,GAAQ+H,GAAa,SAACjE,EAAGC,UACrDgE,EAAYjH,IAAIgD,EAAE,GAAIC,OAE1BhD,MAAO,SAACf,EAAOK,UACbA,EAAKqC,YAAYzD,EAAae,GAAQ+H,GAAa,SAACjE,EAAGC,UACrDgE,EAAYhH,MAAM+C,EAAE,GAAIC,OAE5B9C,OAAQ,SAACjB,EAAOK,OACVsC,EAAQ3C,eACR8E,SAAAA,EAAYmD,eAEd5H,EAAOA,EAAK0C,YAAY+B,EAAWmD,YADnCtF,EAAQ3C,EAAM8E,EAAWmD,aAC8BF,IAElD1H,EAAKqC,YACVzD,EAAa0D,GACboF,GACA,SAACjE,EAAGC,UAAcgE,EAAY9G,OAAO6C,EAAE,GAAIC,OAG/C7C,SAAU,SAAClB,EAAOK,SACVsC,EAAQtC,EAAKqC,YACjBzD,EAAae,GACb+H,GACA,SAACjE,EAAGC,UAAcgE,EAAY7G,SAAS4C,EAAE,GAAIC,mBAE3Ce,SAAAA,EAAYmD,qBACJnD,EAAWmD,aAActF,KAE5BA,GAGX3B,qBAAsB,SAAChB,EAAOK,OACxBsC,EAAQ3C,WACR8E,SAAAA,EAAYmD,YAAa,IAGR,iBAAVjI,GACG,OAAVA,KACE8E,EAAWmD,eAAejI,UAErBK,EAAKC,sDANwDwE,EAAWmD,iBASjF5H,EAAOA,EAAK0C,YAAY+B,EAAWmD,YADnCtF,EAAS3C,EAAkC8E,EAAWmD,aACCF,UAGlDjI,MAAMkI,QAAQrF,GACjBtC,EAAK2C,gBACH/D,EAAa0D,GACboF,GACA,SAACjE,EAAGC,UAAcgE,EAAY/G,qBAAqB8C,EAAE,GAAIC,MAE3D1D,EAAKC,4CJjDNC,EAAsB,CAC3BG,KAAM,UACNE,SAAUT,EAAYsD,GACtB3C,IAAK,SAAAd,SAA2B,kBAAVA,EAAsBA,EAAkB,SAAVA,gCCjCtDQ,EACAmD,SAEO,CACLjD,KAAM,6BAAkBF,EAAOE,WAAUX,EAAgB4D,QACzDhD,kBAAmB,SAACmD,EAAGzD,UACrBqD,EAAcI,EAAGH,GAAgB,GAAKnD,EAAOG,kBAAkBmD,EAAGzD,IACpEQ,oBAAqB,SAACiD,EAAGzD,UACvBqD,EAAcI,EAAGH,GAAgB,GAAKnD,EAAOK,oBAAoBiD,EAAGzD,IACtES,IAAK,SAACgD,EAAGzD,UACPqD,EAAcI,EAAGH,GAAgBA,EAAenD,EAAOM,IAAIgD,EAAGzD,IAChEU,MAAO,SAAC+C,EAAGzD,UACTqD,EAAcI,EAAGH,GAAgBA,EAAenD,EAAOO,MAAM+C,EAAGzD,IAClEW,qBAAsB,SAAC8C,EAAGzD,UACxBqD,EAAcI,EAAGH,GACb,GACAnD,EAAOQ,qBAAqB8C,EAAGzD,IACrCY,OAAQ,SAAC6C,EAAGzD,UACVqD,EAAcI,EAAGH,GAAgBA,EAAenD,EAAOS,OAAO6C,EAAGzD,IACnEa,SAAU,SAAC4C,EAAGzD,UACZqD,EAAcI,EAAGH,GAAgBA,EAAenD,EAAOU,SAAS4C,EAAGzD,yDCkEvEuC,OAEMsF,EAAatE,EAAKhB,GAClBuF,OAAsBD,UAE5BC,EAAejH,SAAW,SAAClB,EAAOK,SAWzB,CAAE+H,MALO7I,EALkB2I,EAAWhH,SAASlB,EAAOK,IAKvBS,KAAI,kBAAmB,CAC3DkF,EAAG,CAAEpE,UACLyG,aAMJF,EAAelH,OAAS,SAACjB,EAAOK,QAExB,UAAWL,SACR,OAGIb,EAAYa,EAAnBoI,MAMDtI,MAAMkI,QAAQ7I,KACjBA,EAAU,CAACA,cAIPmJ,EAAmC,wrBACtBnJ,kBAAS,KAAjB2D,UACTwF,EAAQxF,EAAKkD,EAAEpE,KAAOkB,EAAKuF,SAKtBH,EAAWjH,OAAOqH,EAASjI,IAGpC8H,EAAenH,qBAAuB,SAAChB,EAAOK,MACvB,iBAAVL,GAAgC,OAAVA,SACxBK,EAAKC,YAIR,UAAWN,SACR,OAGLb,EAAWa,EAA6B,MAIvCF,MAAMkI,QAAQ7I,KACjBA,EAAU,CAACA,YAIPmJ,EAAmC,GAEhClJ,EAAQ,EAAGA,EAAQD,EAAQE,OAAQD,IAAS,KAC7CgJ,EAAQjJ,EAAQC,MAED,iBAAVgJ,GAAgC,OAAVA,SACxB/H,EAAKC,KAAK,+CAIb,MAAO8H,MAAY,QAAUA,EAAwBpC,UAClD3F,EAAKC,KACV,8DAMJgI,EADmBF,EACApC,EAAEpE,KADFwG,EACoBC,SAKlCH,EAAWlH,qBAAqBsH,EAASjI,IAG3C8H,wCGjLPI,EACAC,EACAC,EACAC,EACA5D,OAEM6D,EAAiB,SACrB3I,EACA4I,EACA7D,eAAAA,IAAAA,GAAkB,GAGC,iBAAV/E,GACG,OAAVA,IACE+E,GAyDR,SAA+B/E,EAAe6I,SAE1C,MAAO7I,GACmC,iBAAlCA,EAAwB,GAC/B6I,KAAoB7I,EAAwC,EA7D/C8I,CAAsB9I,EAAO4I,KACrC7D,GAAW6D,KAAgC5I,GAC/C,KACM+I,EAAqBhE,EACtB/E,EAAwC,EACvC4I,GAED5I,EACC4I,MAG0B,iBAAvBG,GACPA,KAAsBN,SAEfA,EAAiBM,UAGrBN,EAAiBC,UAEnB,CACLhI,KAAM,uCACkB8H,OAA0BjJ,EAC9CkJ,GAEC3H,KAAI,wBAAcJ,QAClB6C,KAAK,WACVzC,IAAK,SAACd,EAAOK,UACXsI,EAAe3I,EAAOwI,GAAuB1H,IAAId,EAAOK,IAC1DU,MAAO,SAACf,EAAOK,UACbsI,EAAe3I,EAAOuI,GAA6BxH,MAAMf,EAAOK,IAClEM,kBAAmB,SAACX,EAAOK,UACzBsI,EAAe3I,EAAOwI,GAAuB7H,kBAC3CX,EACAK,IAEJQ,oBAAqB,SAACb,EAAOK,UAC3BsI,EAAe3I,EAAOuI,GAA6B1H,oBACjDb,EACAK,IAEJY,OAAQ,SAACjB,EAAOK,gBACdsI,EACE3I,iBACA8E,SAAAA,EAAYE,WAAWwD,QACvB1D,SAAAA,EAAYC,QACZ9D,OAAOjB,EAAOK,IAClBa,SAAU,SAAClB,EAAOK,UAChBsI,EAAe3I,EAAOuI,GAA6BrH,SAASlB,EAAOK,IACrEW,qBAAsB,SAAChB,EAAOK,gBAC5BsI,EACE3I,iBACA8E,SAAAA,EAAYE,WAAWwD,QACvB1D,SAAAA,EAAYC,QACZ/D,qBAAqBhB,EAAOK,mEFyDlC2I,EACA7E,UAEOE,OAAmB2E,EAAmB7E,aAAiBA,mCAY9D6E,EACA7E,UAEO5C,OAAYyH,EAAmB7E,aAAiBA,yCAjCvD6E,EACA7E,UAEOD,OAAkB8E,EAAmB7E,aAAiBA,2BGpHpC8E,ORmGzBC,EAGEC,EADEC,EQpGEC,GRkGNH,EQlGuBD,ERoGnBG,GAAM,EAEH,cACDA,EAAK,OAAOD,EAChBC,GAAM,6BAFsBpF,2BAAAA,yBAG5BmF,EAAOD,EAAKI,MAAMC,KAAMvF,WQxGnB,CACLtD,KAAM,yBAAc2I,IAAY3I,YAChCI,IAAK,0BAAauI,KAAYvI,wBAC9BC,MAAO,0BAAasI,KAAYtI,0BAChCJ,kBAAmB,0BAAa0I,KAAY1I,sCAC5CE,oBAAqB,0BAAawI,KAAYxI,wCAC9CI,OAAQ,0BAAaoI,KAAYpI,2BACjCC,SAAU,0BAAamI,KAAYnI,6BACnCF,qBAAsB,0BACpBqI,KAAYrI,oECJSwI,UAGlBjJ,EAAsB,CAC3BG,gBAAiBX,EAAgByJ,OACjC5I,SAAUT,GAJK,SAACH,UAA+BwJ,IAAiBxJ,KAKhEc,IAJU,kBAAM0I,gCCNlBhJ,SAEO,CACLE,KAAM,6BAAkBF,EAAOE,YAC/BC,kBAAmB,SAACX,EAAOK,UACf,OAAVL,EAAiB,GAAKQ,EAAOG,kBAAkBX,EAAOK,IACxDQ,oBAAqB,SAACb,EAAOK,UACjB,OAAVL,EAAiB,GAAKQ,EAAOK,oBAAoBb,EAAOK,IAC1DS,IAAK,SAACd,EAAOK,UAAoB,OAAVL,EAAiB,KAAOQ,EAAOM,IAAId,EAAOK,IACjEU,MAAO,SAACf,EAAOK,UAAoB,OAAVL,EAAiB,KAAOQ,EAAOO,MAAMf,EAAOK,IACrEW,qBAAsB,SAAChB,EAAOK,UAClB,OAAVL,EAAiB,GAAKQ,EAAOQ,qBAAqBhB,EAAOK,IAC3DY,OAAQ,SAACjB,EAAOK,UACJ,OAAVL,EAAiB,KAAOQ,EAAOS,OAAOjB,EAAOK,IAC/Ca,SAAU,SAAClB,EAAOK,UACN,OAAVL,EAAiB,KAAOQ,EAAOU,SAASlB,EAAOK,qBRDrD,kBACSE,EAAsB,CAC3BG,KAAM,SACNE,SAAUT,EAAYgB,GACtBL,IAAKO,iCSNPoI,OAEM7I,EAAWT,EAfnB,SACEsJ,OAEMC,EAAahK,OAAOiK,OAAOF,UAC1B,SAACzJ,UACNmB,EAAgBnB,IAChB0J,EAAWE,SAASvI,EAA4BrB,KASrB6J,CAAkBJ,WAExClJ,EAAsB,CAC3BG,aAAchB,OAAOiK,OAAOF,GACzBK,QAAO,SAAAhG,SAAkB,iBAANA,KACnBP,KAAK,SACRzC,IAAKO,EACLT,SAAUA,gDCrBZJ,SAEO,CACLE,KAAM,6BAAkBF,EAAOE,YAC/BC,kBAAmB,SAACX,EAAOK,eACfuH,IAAV5H,EAAsB,GAAKQ,EAAOG,kBAAkBX,EAAOK,IAC7DQ,oBAAqB,SAACb,EAAOK,eACjBuH,IAAV5H,EAAsB,GAAKQ,EAAOK,oBAAoBb,EAAOK,IAC/DS,IAAK,SAACd,EAAOK,eACDuH,IAAV5H,OAAsB4H,EAAYpH,EAAOM,IAAId,EAAOK,IACtDU,MAAO,SAACf,EAAOK,eACHuH,IAAV5H,OAAsB4H,EAAYpH,EAAOO,MAAMf,EAAOK,IACxDW,qBAAsB,SAAChB,EAAOK,eAClBuH,IAAV5H,EAAsB,GAAKQ,EAAOQ,qBAAqBhB,EAAOK,IAChEY,OAAQ,SAACjB,EAAOK,eACJuH,IAAV5H,OAAsB4H,EAAYpH,EAAOS,OAAOjB,EAAOK,IACzDa,SAAU,SAAClB,EAAOK,eACNuH,IAAV5H,OAAsB4H,EAAYpH,EAAOU,SAASlB,EAAOK,4CVZ/D,kBACSE,EAAsB,CAC3BG,KAAM,SACNE,SAAUT,EAAYqD,GACtB1C,IAAKZ,iCWEPuJ,OAEM7I,EAAWT,EAdnB,SACEsJ,OAEMC,EAAahK,OAAOiK,OAAOF,UAC1B,SAACzJ,SACW,iBAAVA,GAAsB0J,EAAWE,SAAS5J,IAStB6J,CAAkBJ,WAExClJ,EAAsB,CAC3BG,aAAchB,OAAOiK,OAAOF,GACzB3I,IAAIf,GACJwD,KAAK,SACRzC,IAAKZ,EACLU,SAAUA,qBCrBd,kBACSL,EAAsB,CAC3BG,KAAM,UACNE,SAAU,iBAAM,IAChBE,IAAKZ,qCbmFPF,EACAQ,OAEMuJ,EAAiBzH,EACrBH,EAAuBnC,EAAOQ,EAAOE,SAEjCsJ,EAAmBxJ,EAAOG,kBAAkBX,EAAO+J,UACzB,IAA5BC,EAAiB3K,OACZ,CAAE2H,QAAQ,EAAOiD,OAAQzJ,EAAOM,IAAId,EAAO+J,IAE3C,CAAE/C,OAAQgD,uCAoCnBhK,EACAQ,OAEMuJ,EAAiBzH,EACrBH,EAAuBnC,EAAOQ,EAAOE,SAEjCsJ,EAAmBxJ,EAAOQ,qBAAqBhB,EAAO+J,UAC5B,IAA5BC,EAAiB3K,OACZ,CAAE2H,QAAQ,EAAOiD,OAAQzJ,EAAOS,OAAOjB,EAAO+J,IAE9C,CAAE/C,OAAQgD,sCAjCnBhK,EACAQ,OAEMuJ,EAAiBzH,EACrBH,EAAuBnC,EAAOQ,EAAOE,SAEjCsJ,EAAmBxJ,EAAOK,oBAAoBb,EAAO+J,UAC3B,IAA5BC,EAAiB3K,OACZ,CAAE2H,QAAQ,EAAOiD,OAAQzJ,EAAOO,MAAMf,EAAO+J,IAE7C,CAAE/C,OAAQgD,yCAoCnBhK,EACAQ,OAEMuJ,EAAiBzH,EACrBH,EAAuBnC,EAAOQ,EAAOE,SAEjCsJ,EAAmBxJ,EAAOK,oBAAoBb,EAAO+J,UAC3B,IAA5BC,EAAiB3K,OACZ,CAAE2H,QAAQ,EAAOiD,OAAQzJ,EAAOU,SAASlB,EAAO+J,IAEhD,CAAE/C,OAAQgD"}