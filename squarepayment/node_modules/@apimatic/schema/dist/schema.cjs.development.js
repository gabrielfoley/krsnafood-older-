'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var flatten = _interopDefault(require('lodash.flatten'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

/**
 * Utilities for internal library usage
 */
function arrayEntries(arr) {
  var entries = [];

  for (var index = 0; index < arr.length; index++) {
    var element = arr[index];
    entries.push([index, element]);
  }

  return entries;
}
function objectEntries(obj) {
  var ownProps = Object.keys(obj),
      i = ownProps.length,
      resArray = new Array(i); // preallocate the Array

  while (i--) {
    resArray[i] = [ownProps[i], obj[ownProps[i]]];
  }

  return resArray;
}
function literalToString(value) {
  return typeof value === 'string' ? "\"" + value.replace(/"/g, '"') + "\"" : "" + value;
}
function identityFn(value) {
  return value;
}
function toValidator(fn) {
  return function (value, ctxt) {
    return fn(value) ? [] : ctxt.fail();
  };
}
/**
 * Create a schema in which the mapping and unmapping is done the same way
 */

function createSymmetricSchema(schema) {
  return createBasicSchema({
    type: function type() {
      return schema.type;
    },
    validateBeforeMap: schema.validate,
    validateBeforeUnmap: schema.validate,
    map: schema.map,
    unmap: schema.map
  });
}
/** Create a basic schema where XML mapping and validation is the same as for JSON */

function createBasicSchema(basicSchema) {
  return _extends({}, basicSchema, {
    validateBeforeMapXml: basicSchema.validateBeforeUnmap,
    mapXml: basicSchema.map,
    unmapXml: basicSchema.unmap
  });
}

function isNumericString(value) {
  return typeof value === 'number' || typeof value === 'string' && !isNaN(value);
}
function coerceNumericStringToNumber(value) {
  return typeof value === 'number' ? value : +value;
}
function once(func) {
  var ran = false,
      memo;
  return function () {
    if (ran) return memo;
    ran = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    memo = func.apply(this, args);
    return memo;
  };
}
/**
 * Returns a copy of the object with the given keys omitted.
 */

function omitKeysFromObject(object, keysToOmit) {
  var omitSet = new Set(keysToOmit);
  var output = {};

  for (var key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && !omitSet.has(key)) {
      output[key] = object[key];
    }
  }

  return output;
}
function objectKeyEncode(key) {
  return key.indexOf(' ') !== -1 ? literalToString(key) : key;
}

/**
 * Validate and map the value using the given schema.
 *
 * This method should be used after JSON deserialization.
 *
 * @param value Value to map
 * @param schema Schema for type
 */

function validateAndMap(value, schema) {
  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));
  var validationResult = schema.validateBeforeMap(value, contextCreator);

  if (validationResult.length === 0) {
    return {
      errors: false,
      result: schema.map(value, contextCreator)
    };
  } else {
    return {
      errors: validationResult
    };
  }
}
/**
 * Valudate and unmap the value using the given schema.
 *
 * This method should be used before JSON serializatin.
 *
 * @param value Value to unmap
 * @param schema Schema for type
 */

function validateAndUnmap(value, schema) {
  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));
  var validationResult = schema.validateBeforeUnmap(value, contextCreator);

  if (validationResult.length === 0) {
    return {
      errors: false,
      result: schema.unmap(value, contextCreator)
    };
  } else {
    return {
      errors: validationResult
    };
  }
}
/**
 * Validate and map the value using the given schema.
 *
 * This method should be used after XML deserialization.
 *
 * @param value Value to map
 * @param schema Schema for type
 */

function validateAndMapXml(value, schema) {
  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));
  var validationResult = schema.validateBeforeMapXml(value, contextCreator);

  if (validationResult.length === 0) {
    return {
      errors: false,
      result: schema.mapXml(value, contextCreator)
    };
  } else {
    return {
      errors: validationResult
    };
  }
}
/**
 * Valudate and unmap the value using the given schema.
 *
 * This method should be used before XML serialization.
 *
 * @param value Value to unmap
 * @param schema Schema for type
 */

function validateAndUnmapXml(value, schema) {
  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));
  var validationResult = schema.validateBeforeUnmap(value, contextCreator);

  if (validationResult.length === 0) {
    return {
      errors: false,
      result: schema.unmapXml(value, contextCreator)
    };
  } else {
    return {
      errors: validationResult
    };
  }
}
/**
 * Create a new schema context using the given value and type.
 */

function createNewSchemaContext(value, type) {
  return {
    value: value,
    type: type,
    branch: [value],
    path: []
  };
}
/**
 * Create a new SchemaContextCreator for the given SchemaContext.
 */


function createSchemaContextCreator(currentContext) {
  var createChildContext = function createChildContext(key, value, childSchema) {
    return createSchemaContextCreator({
      value: value,
      type: childSchema.type(),
      branch: [].concat(currentContext.branch, [value]),
      path: [].concat(currentContext.path, [key])
    });
  };

  var mapChildren = function mapChildren(items, itemSchema, mapper) {
    return items.map(function (item) {
      return mapper(item, createChildContext(item[0], item[1], itemSchema));
    });
  };

  return _extends({}, currentContext, {
    createChild: createChildContext,
    flatmapChildren: function flatmapChildren() {
      return flatten(mapChildren.apply(void 0, arguments));
    },
    mapChildren: mapChildren,
    fail: function fail(message) {
      return [_extends({}, currentContext, {
        message: createErrorMessage(currentContext, message)
      })];
    }
  });
}

function createErrorMessage(ctxt, message) {
  var _message;

  message = ((_message = message) != null ? _message : "Expected value to be of type '" + ctxt.type + "' but found '" + typeof ctxt.value + "'.") + '\n' + ("\nGiven value: " + JSON.stringify(ctxt.value)) + ("\nType: '" + typeof ctxt.value + "'") + ("\nExpected type: '" + ctxt.type + "'");

  if (ctxt.path.length > 0) {
    var pathString = ctxt.path.map(function (value) {
      return objectKeyEncode(value.toString());
    }).join(' â€º ');
    message += "\nPath: " + pathString;
  }

  return message;
}

/**
 * Create an array schema.
 *
 * The array must be a homogenous array confirming to the itemsSchema. Each item
 * will be mapped/unmapped using the itemsSchema.
 */

function array(itemsSchema, xmlOptions) {
  var arraySchema;
  arraySchema = {
    type: function type() {
      return "Array<" + itemsSchema.type() + ">";
    },
    validateBeforeMap: function validateBeforeMap(value, ctxt) {
      return Array.isArray(value) ? ctxt.flatmapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {
        return itemsSchema.validateBeforeMap(v[1], childCtxt);
      }) : ctxt.fail();
    },
    validateBeforeUnmap: function validateBeforeUnmap(value, ctxt) {
      return Array.isArray(value) ? ctxt.flatmapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {
        return itemsSchema.validateBeforeUnmap(v[1], childCtxt);
      }) : ctxt.fail();
    },
    map: function map(value, ctxt) {
      return ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {
        return itemsSchema.map(v[1], childCtxt);
      });
    },
    unmap: function unmap(value, ctxt) {
      return ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {
        return itemsSchema.unmap(v[1], childCtxt);
      });
    },
    mapXml: function mapXml(value, ctxt) {
      var items = value;

      if (xmlOptions == null ? void 0 : xmlOptions.xmlItemName) {
        items = value[xmlOptions.xmlItemName];
        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);
      }

      return ctxt.mapChildren(arrayEntries(items), itemsSchema, function (v, childCtxt) {
        return itemsSchema.mapXml(v[1], childCtxt);
      });
    },
    unmapXml: function unmapXml(value, ctxt) {
      var items = ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {
        return itemsSchema.unmapXml(v[1], childCtxt);
      });

      if (xmlOptions == null ? void 0 : xmlOptions.xmlItemName) {
        var _ref;

        return _ref = {}, _ref[xmlOptions.xmlItemName] = items, _ref;
      } else {
        return items;
      }
    },
    validateBeforeMapXml: function validateBeforeMapXml(value, ctxt) {
      var items = value;

      if (xmlOptions == null ? void 0 : xmlOptions.xmlItemName) {
        var errorMessage = "Expected array to be wrapped with XML element " + xmlOptions.xmlItemName + ".";

        if (typeof value !== 'object' || value === null || !(xmlOptions.xmlItemName in value)) {
          return ctxt.fail(errorMessage);
        }

        items = value[xmlOptions.xmlItemName];
        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);
      }

      return Array.isArray(items) ? ctxt.flatmapChildren(arrayEntries(items), itemsSchema, function (v, childCtxt) {
        return itemsSchema.validateBeforeMapXml(v[1], childCtxt);
      }) : ctxt.fail();
    }
  };
  return arraySchema;
}

function isValidStringValue(value) {
  return typeof value === 'string';
}
/** Create a string schema. */


function string() {
  return createSymmetricSchema({
    type: 'string',
    validate: toValidator(isValidStringValue),
    map: identityFn
  });
}
/** Create a number schema. */

function number() {
  return createSymmetricSchema({
    type: 'number',
    validate: toValidator(isNumericString),
    map: coerceNumericStringToNumber
  });
}

function isValidBooleanValue(value) {
  return typeof value === 'boolean' || typeof value === 'string' && (value === 'true' || value === 'false');
}
/** Create a boolean schema. */


function _boolean() {
  return createSymmetricSchema({
    type: 'boolean',
    validate: toValidator(isValidBooleanValue),
    map: function map(value) {
      return typeof value === 'boolean' ? value : value === 'true';
    }
  });
}

/**
 * Create a 'defaults' schema.
 *
 * During mapping or unmapping, if the value is null or undefined, the schema
 * defaults to the 'defaultValue' specified in the schema.
 */

function defaults(schema, defaultValue) {
  return {
    type: function type() {
      return "Defaults<" + schema.type() + "," + literalToString(defaultValue) + ">";
    },
    validateBeforeMap: function validateBeforeMap(v, ctxt) {
      return shouldDefault(v, defaultValue) ? [] : schema.validateBeforeMap(v, ctxt);
    },
    validateBeforeUnmap: function validateBeforeUnmap(v, ctxt) {
      return shouldDefault(v, defaultValue) ? [] : schema.validateBeforeUnmap(v, ctxt);
    },
    map: function map(v, ctxt) {
      return shouldDefault(v, defaultValue) ? defaultValue : schema.map(v, ctxt);
    },
    unmap: function unmap(v, ctxt) {
      return shouldDefault(v, defaultValue) ? defaultValue : schema.unmap(v, ctxt);
    },
    validateBeforeMapXml: function validateBeforeMapXml(v, ctxt) {
      return shouldDefault(v, defaultValue) ? [] : schema.validateBeforeMapXml(v, ctxt);
    },
    mapXml: function mapXml(v, ctxt) {
      return shouldDefault(v, defaultValue) ? defaultValue : schema.mapXml(v, ctxt);
    },
    unmapXml: function unmapXml(v, ctxt) {
      return shouldDefault(v, defaultValue) ? defaultValue : schema.unmapXml(v, ctxt);
    }
  };
}

function shouldDefault(value, defaultValue) {
  return value === null || value === undefined || value === defaultValue;
}

/**
 * Create a dictionary schema.
 *
 * This can be used to map/unmap a type like Record<string, something>.
 */

function dict(itemSchema) {
  var validate = function validate(validateFn, value, ctxt) {
    if (typeof value !== 'object' || value === null) {
      return ctxt.fail();
    }

    var valueObject = value;
    return ctxt.flatmapChildren(objectEntries(valueObject), itemSchema, function (v, childCtxt) {
      return itemSchema[validateFn](v[1], childCtxt);
    });
  };

  return {
    type: function type() {
      return "Record<string," + itemSchema.type() + ">";
    },
    validateBeforeMap: function validateBeforeMap() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return validate.apply(void 0, ['validateBeforeMap'].concat(args));
    },
    validateBeforeUnmap: function validateBeforeUnmap() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return validate.apply(void 0, ['validateBeforeUnmap'].concat(args));
    },
    map: function map(value, ctxt) {
      var output = {};

      for (var key in value) {
        /* istanbul ignore else */
        if (Object.prototype.hasOwnProperty.call(value, key)) {
          var propValue = value[key];
          output[key] = itemSchema.map(propValue, ctxt.createChild(key, propValue, itemSchema));
        }
      }

      return output;
    },
    unmap: function unmap(value, ctxt) {
      var output = {};

      for (var key in value) {
        /* istanbul ignore else */
        if (Object.prototype.hasOwnProperty.call(value, key)) {
          var propValue = value[key];
          output[key] = itemSchema.unmap(propValue, ctxt.createChild(key, propValue, itemSchema));
        }
      }

      return output;
    },
    validateBeforeMapXml: function validateBeforeMapXml() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return validate.apply(void 0, ['validateBeforeMapXml'].concat(args));
    },
    mapXml: function mapXml(value, ctxt) {
      var output = {};

      for (var key in value) {
        /* istanbul ignore else */
        if (Object.prototype.hasOwnProperty.call(value, key)) {
          var propValue = value[key];
          output[key] = itemSchema.mapXml(propValue, ctxt.createChild(key, propValue, itemSchema));
        }
      }

      return output;
    },
    unmapXml: function unmapXml(value, ctxt) {
      var output = {};

      for (var key in value) {
        /* istanbul ignore else */
        if (Object.prototype.hasOwnProperty.call(value, key)) {
          var propValue = value[key];
          output[key] = itemSchema.unmapXml(propValue, ctxt.createChild(key, propValue, itemSchema));
        }
      }

      return output;
    }
  };
}
function dictWithXmlEntries(itemSchema) {
  var dictSchema = dict(itemSchema);

  var modifiedSchema = _extends({}, dictSchema);

  modifiedSchema.unmapXml = function (value, ctxt) {
    var output = dictSchema.unmapXml(value, ctxt); // Convert each entry to XML "entry" elements. The XML "entry" element looks
    // like this: `<entry key="key">value</entry>`. Note that the element name
    // "entry" is set later at the return.

    var entries = objectEntries(output).map(function (_ref) {
      var key = _ref[0],
          value = _ref[1];
      return {
        $: {
          key: key
        },
        _: value
      };
    });
    return {
      entry: entries
    };
  };

  modifiedSchema.mapXml = function (value, ctxt) {
    // Empty dictionary
    if (!('entry' in value)) {
      return {};
    }

    var entries = value.entry; // For a single entry, the XML parser gives a single object instead of an array.
    // Make it an array for easier handling.

    if (!Array.isArray(entries)) {
      entries = [entries];
    } // Convert entry elements containing a key attribute and content to a dictionary.


    var dictObj = {};

    for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {
      var item = _step.value;
      dictObj[item.$.key] = item._;
    } // Run validation on entry values against the item schema.
    // TODO: Maintain context and path when delegating validatin


    return dictSchema.mapXml(dictObj, ctxt);
  };

  modifiedSchema.validateBeforeMapXml = function (value, ctxt) {
    if (typeof value !== 'object' || value === null) {
      return ctxt.fail();
    } // Empty dictionary case


    if (!('entry' in value)) {
      return [];
    }

    var entries = value['entry']; // Non-repeating XML elements are passed as a single-object instead of an array of objects.
    // We normalize this behavior of the XML parser.

    if (!Array.isArray(entries)) {
      entries = [entries];
    } // Dictionary for all entries


    var dictObj = {};

    for (var index = 0; index < entries.length; index++) {
      var entry = entries[index]; // Fail if entry is not an XML element object.

      if (typeof entry !== 'object' || entry === null) {
        return ctxt.fail('Expected "entry" to be an XML element.');
      } // Fail if entry does not have an attribute named key.


      if (!('$' in entry) || !('key' in entry.$)) {
        return ctxt.fail('Expected "entry" element to have an attribute named "key".');
      } // Set entry in dictionary


      var typedEntry = entry;
      dictObj[typedEntry.$.key] = typedEntry._;
    } // Check all entry values against the item schema.
    // TODO: Maintain context and path when delegating validation


    return dictSchema.validateBeforeMapXml(dictObj, ctxt);
  };

  return modifiedSchema;
}

function discriminatedObject(discriminatorMappedPropName, discriminatorPropName, discriminatorMap, defaultDiscriminator, xmlOptions) {
  var schemaSelector = function schemaSelector(value, discriminatorProp, isAttr) {
    if (isAttr === void 0) {
      isAttr = false;
    }

    if (typeof value === 'object' && value !== null && (isAttr && xmlObjectHasAttribute(value, discriminatorProp) || !isAttr && discriminatorProp in value)) {
      var discriminatorValue = isAttr ? value['$'][discriminatorProp] : value[discriminatorProp];

      if (typeof discriminatorValue === 'string' && discriminatorValue in discriminatorMap) {
        return discriminatorMap[discriminatorValue];
      }
    }

    return discriminatorMap[defaultDiscriminator];
  };

  return {
    type: function type() {
      return "DiscriminatedUnion<" + discriminatorPropName + ",[" + objectEntries(discriminatorMap).map(function (_ref) {
        var v = _ref[1];
        return v.type;
      }).join(',') + "]>";
    },
    map: function map(value, ctxt) {
      return schemaSelector(value, discriminatorPropName).map(value, ctxt);
    },
    unmap: function unmap(value, ctxt) {
      return schemaSelector(value, discriminatorMappedPropName).unmap(value, ctxt);
    },
    validateBeforeMap: function validateBeforeMap(value, ctxt) {
      return schemaSelector(value, discriminatorPropName).validateBeforeMap(value, ctxt);
    },
    validateBeforeUnmap: function validateBeforeUnmap(value, ctxt) {
      return schemaSelector(value, discriminatorMappedPropName).validateBeforeUnmap(value, ctxt);
    },
    mapXml: function mapXml(value, ctxt) {
      var _xmlOptions$xmlName;

      return schemaSelector(value, (_xmlOptions$xmlName = xmlOptions == null ? void 0 : xmlOptions.xmlName) != null ? _xmlOptions$xmlName : discriminatorPropName, xmlOptions == null ? void 0 : xmlOptions.isAttr).mapXml(value, ctxt);
    },
    unmapXml: function unmapXml(value, ctxt) {
      return schemaSelector(value, discriminatorMappedPropName).unmapXml(value, ctxt);
    },
    validateBeforeMapXml: function validateBeforeMapXml(value, ctxt) {
      var _xmlOptions$xmlName2;

      return schemaSelector(value, (_xmlOptions$xmlName2 = xmlOptions == null ? void 0 : xmlOptions.xmlName) != null ? _xmlOptions$xmlName2 : discriminatorPropName, xmlOptions == null ? void 0 : xmlOptions.isAttr).validateBeforeMapXml(value, ctxt);
    }
  };
}

function xmlObjectHasAttribute(value, prop) {
  return '$' in value && typeof value['$'] === 'object' && prop in value['$'];
}

/**
 * Create a schema that lazily delegates to the given schema.
 */

function lazy(schemaFn) {
  var getSchema = once(schemaFn); // Memoize schema

  return {
    type: function type() {
      return "Lazy<" + getSchema().type() + ">";
    },
    map: function map() {
      var _getSchema;

      return (_getSchema = getSchema()).map.apply(_getSchema, arguments);
    },
    unmap: function unmap() {
      var _getSchema2;

      return (_getSchema2 = getSchema()).unmap.apply(_getSchema2, arguments);
    },
    validateBeforeMap: function validateBeforeMap() {
      var _getSchema3;

      return (_getSchema3 = getSchema()).validateBeforeMap.apply(_getSchema3, arguments);
    },
    validateBeforeUnmap: function validateBeforeUnmap() {
      var _getSchema4;

      return (_getSchema4 = getSchema()).validateBeforeUnmap.apply(_getSchema4, arguments);
    },
    mapXml: function mapXml() {
      var _getSchema5;

      return (_getSchema5 = getSchema()).mapXml.apply(_getSchema5, arguments);
    },
    unmapXml: function unmapXml() {
      var _getSchema6;

      return (_getSchema6 = getSchema()).unmapXml.apply(_getSchema6, arguments);
    },
    validateBeforeMapXml: function validateBeforeMapXml() {
      var _getSchema7;

      return (_getSchema7 = getSchema()).validateBeforeMapXml.apply(_getSchema7, arguments);
    }
  };
}

function literal(literalValue) {
  var validate = function validate(value) {
    return literalValue === value;
  };

  var map = function map() {
    return literalValue;
  };

  return createSymmetricSchema({
    type: "Literal<" + literalToString(literalValue) + ">",
    validate: toValidator(validate),
    map: map
  });
}

/**
 * Creates a nullable schema.
 *
 * The nullable schema allows null values or the values allowed by the given
 * 'schema'.
 */
function nullable(schema) {
  return {
    type: function type() {
      return "Nullable<" + schema.type() + ">";
    },
    validateBeforeMap: function validateBeforeMap(value, ctxt) {
      return value === null ? [] : schema.validateBeforeMap(value, ctxt);
    },
    validateBeforeUnmap: function validateBeforeUnmap(value, ctxt) {
      return value === null ? [] : schema.validateBeforeUnmap(value, ctxt);
    },
    map: function map(value, ctxt) {
      return value === null ? null : schema.map(value, ctxt);
    },
    unmap: function unmap(value, ctxt) {
      return value === null ? null : schema.unmap(value, ctxt);
    },
    validateBeforeMapXml: function validateBeforeMapXml(value, ctxt) {
      return value === null ? [] : schema.validateBeforeMapXml(value, ctxt);
    },
    mapXml: function mapXml(value, ctxt) {
      return value === null ? null : schema.mapXml(value, ctxt);
    },
    unmapXml: function unmapXml(value, ctxt) {
      return value === null ? null : schema.unmapXml(value, ctxt);
    }
  };
}

function createEnumChecker(enumVariable) {
  var enumValues = Object.values(enumVariable);
  return function (value) {
    return isNumericString(value) && enumValues.includes(coerceNumericStringToNumber(value));
  };
}
/**
 * Create a schema for a number enumeration.
 */


function numberEnum(enumVariable) {
  var validate = toValidator(createEnumChecker(enumVariable));
  return createSymmetricSchema({
    type: "Enum<" + Object.values(enumVariable).filter(function (v) {
      return typeof v === 'number';
    }).join(',') + ">",
    map: coerceNumericStringToNumber,
    validate: validate
  });
}

/**
 * Create a Strict Object type schema.
 *
 * A strict-object does not allow additional properties during mapping or
 * unmapping. Additional properties will result in a validation error.
 */

function strictObject(objectSchema) {
  var schema = internalObject(objectSchema, false, false);

  schema.type = function () {
    return "StrictObject<{" + Object.keys(objectSchema).map(objectKeyEncode).join(',') + "}>";
  };

  return schema;
}
/**
 * Create an Expandable Object type schema.
 *
 * The object schema allows additional properties during mapping and unmapping. The
 * additional properties are copied over as is.
 */

function expandoObject(objectSchema) {
  return internalObject(objectSchema, true, true);
}
/**
 * Create an Object Type schema.
 *
 * The Object schema allows additional properties during mapping and unmapping
 * but discards them.
 */

function object(objectSchema) {
  var schema = internalObject(objectSchema, true, false);

  schema.type = function () {
    return "Object<{" + Object.keys(objectSchema).map(objectKeyEncode).join(',') + "}>";
  };

  return schema;
}
/**
 * Create a strict-object schema that extends an existing schema.
 */

function extendStrictObject(parentObjectSchema, objectSchema) {
  return strictObject(_extends({}, parentObjectSchema.objectSchema, objectSchema));
}
/**
 * Create an object schema that extends an existing schema.
 */

function extendExpandoObject(parentObjectSchema, objectSchema) {
  return expandoObject(_extends({}, parentObjectSchema.objectSchema, objectSchema));
}
/**
 * Create an Object schema that extends an existing object schema.
 */

function extendObject(parentObjectSchema, objectSchema) {
  return object(_extends({}, parentObjectSchema.objectSchema, objectSchema));
}
/**
 * Internal utility to create object schema with different options.
 */

function internalObject(objectSchema, skipValidateAdditionalProps, mapAdditionalProps) {
  var keys = Object.keys(objectSchema);
  var reverseObjectSchema = createReverseObjectSchema(objectSchema);
  var xmlMappingInfo = getXmlPropMappingForObjectSchema(objectSchema);
  var xmlObjectSchema = createXmlObjectSchema(objectSchema);
  var reverseXmlObjectSchema = createReverseXmlObjectSchema(xmlObjectSchema);
  return {
    type: function type() {
      return "Object<{" + keys.map(objectKeyEncode).join(',') + ",...}>";
    },
    validateBeforeMap: validateObject(objectSchema, 'validateBeforeMap', skipValidateAdditionalProps),
    validateBeforeUnmap: validateObject(reverseObjectSchema, 'validateBeforeUnmap', skipValidateAdditionalProps),
    map: mapObject(objectSchema, 'map', mapAdditionalProps),
    unmap: mapObject(reverseObjectSchema, 'unmap', mapAdditionalProps),
    validateBeforeMapXml: validateObjectBeforeMapXml(objectSchema, xmlMappingInfo, skipValidateAdditionalProps),
    mapXml: mapObjectFromXml(xmlObjectSchema, mapAdditionalProps),
    unmapXml: unmapObjectToXml(reverseXmlObjectSchema, mapAdditionalProps),
    objectSchema: objectSchema
  };
}

function validateObjectBeforeMapXml(objectSchema, xmlMappingInfo, allowAdditionalProperties) {
  var elementsToProps = xmlMappingInfo.elementsToProps,
      attributesToProps = xmlMappingInfo.attributesToProps;
  return function (value, ctxt) {
    var _attributes;

    if (typeof value !== 'object' || value === null) {
      return ctxt.fail();
    }

    var valueObject = value;

    var attributes = valueObject.$,
        elements = _objectWithoutPropertiesLoose(valueObject, ["$"]);

    attributes = (_attributes = attributes) != null ? _attributes : {}; // Validate all known elements and attributes using the schema

    return [].concat(validateValueObject({
      validationMethod: 'validateBeforeMapXml',
      propTypeName: 'child elements',
      propTypePrefix: 'element',
      valueTypeName: 'element',
      propMapping: elementsToProps,
      objectSchema: objectSchema,
      valueObject: elements,
      ctxt: ctxt,
      allowAdditionalProperties: allowAdditionalProperties
    }), validateValueObject({
      validationMethod: 'validateBeforeMapXml',
      propTypeName: 'attributes',
      propTypePrefix: '@',
      valueTypeName: 'element',
      propMapping: attributesToProps,
      objectSchema: objectSchema,
      valueObject: attributes,
      ctxt: ctxt,
      allowAdditionalProperties: allowAdditionalProperties
    }));
  };
}

function mapObjectFromXml(xmlObjectSchema, allowAdditionalProps) {
  var elementsSchema = xmlObjectSchema.elementsSchema,
      attributesSchema = xmlObjectSchema.attributesSchema;
  var mapElements = mapObject(elementsSchema, 'mapXml', allowAdditionalProps);
  var mapAttributes = mapObject(attributesSchema, 'mapXml', false // Always false; additional attributes are handled differently below.
  ); // These are later used to omit know attribute props from the attributes object
  // so that the remaining props can be copied over as additional props.

  var attributeKeys = objectEntries(attributesSchema).map(function (_ref) {
    var _ref$ = _ref[1],
        name = _ref$[0];
    return name;
  });
  return function (value, ctxt) {
    var _attributes2;

    var valueObject = value;

    var attributes = valueObject.$,
        elements = _objectWithoutPropertiesLoose(valueObject, ["$"]);

    attributes = (_attributes2 = attributes) != null ? _attributes2 : {};

    var output = _extends({}, mapAttributes(attributes, ctxt), mapElements(elements, ctxt));

    if (allowAdditionalProps) {
      // Omit known attributes and copy the rest as additional attributes.
      var additionalAttrs = omitKeysFromObject(attributes, attributeKeys);

      if (Object.keys(additionalAttrs).length > 0) {
        // These additional attrs are set in the '$' property by convention.
        output['$'] = additionalAttrs;
      }
    }

    return output;
  };
}

function unmapObjectToXml(xmlObjectSchema, allowAdditionalProps) {
  var elementsSchema = xmlObjectSchema.elementsSchema,
      attributesSchema = xmlObjectSchema.attributesSchema;
  var mapElements = mapObject(elementsSchema, 'unmapXml', allowAdditionalProps);
  var mapAttributes = mapObject(attributesSchema, 'unmapXml', false // Always false so that element props are not copied during mapping
  ); // These are later used to omit attribute props from the value object so that they
  // do not get mapped during element mapping, if the allowAdditionalProps is true.

  var attributeKeys = objectEntries(attributesSchema).map(function (_ref2) {
    var _ref2$ = _ref2[1],
        name = _ref2$[0];
    return name;
  });
  return function (value, ctxt) {
    // Get additional attributes which are set in the '$' property by convention
    var attributes = value.$,
        rest = _objectWithoutPropertiesLoose(value, ["$"]); // Ensure 'attributes' is an object and non-null


    var additionalAttributes = typeof attributes === 'object' && attributes !== null && allowAdditionalProps ? attributes : {};
    return _extends({}, mapElements(omitKeysFromObject(rest, attributeKeys), ctxt), {
      $: _extends({}, additionalAttributes, mapAttributes(value, ctxt))
    });
  };
}

function validateValueObject(_ref3) {
  var validationMethod = _ref3.validationMethod,
      propTypeName = _ref3.propTypeName,
      propTypePrefix = _ref3.propTypePrefix,
      valueTypeName = _ref3.valueTypeName,
      propMapping = _ref3.propMapping,
      objectSchema = _ref3.objectSchema,
      valueObject = _ref3.valueObject,
      ctxt = _ref3.ctxt,
      allowAdditionalProperties = _ref3.allowAdditionalProperties;
  var errors = [];
  var missingProps = new Set();
  var unknownProps = new Set(Object.keys(valueObject)); // Validate all known properties using the schema

  for (var key in propMapping) {
    var propName = propMapping[key];
    var schema = objectSchema[propName][1];
    unknownProps["delete"](key);

    if (key in valueObject) {
      errors.push.apply(errors, schema[validationMethod](valueObject[key], ctxt.createChild(propTypePrefix + key, valueObject[key], schema)));
    } else if (schema.type().indexOf('Optional<') !== 0) {
      // Add to missing keys if it is not an optional property
      missingProps.add(key);
    }
  } // Create validation error for unknown properties encountered


  var unknownPropsArray = Array.from(unknownProps);

  if (unknownPropsArray.length > 0 && !allowAdditionalProperties) {
    errors.push.apply(errors, ctxt.fail("Some unknown " + propTypeName + " were found in the " + valueTypeName + ": " + unknownPropsArray.map(literalToString).join(', ') + "."));
  } // Create validation error for missing required properties


  var missingPropsArray = Array.from(missingProps);

  if (missingPropsArray.length > 0) {
    errors.push.apply(errors, ctxt.fail("Some " + propTypeName + " are missing in the " + valueTypeName + ": " + missingPropsArray.map(literalToString).join(', ') + "."));
  }

  return errors;
}

function validateObject(objectSchema, validationMethod, allowAdditionalProperties) {
  var propsMapping = getPropMappingForObjectSchema(objectSchema);
  return function (value, ctxt) {
    if (typeof value !== 'object' || value === null) {
      return ctxt.fail();
    }

    return validateValueObject({
      validationMethod: validationMethod,
      propTypeName: 'properties',
      propTypePrefix: '',
      valueTypeName: 'object',
      propMapping: propsMapping,
      objectSchema: objectSchema,
      valueObject: value,
      ctxt: ctxt,
      allowAdditionalProperties: allowAdditionalProperties
    });
  };
}

function mapObject(objectSchema, mappingFn, allowAdditionalProperties) {
  return function (value, ctxt) {
    var output = {};
    var objectValue = value;
    /** Properties seen in the object but not in the schema */

    var unknownKeys = new Set(Object.keys(objectValue)); // Map known properties using the schema

    for (var key in objectSchema) {
      /* istanbul ignore else */
      if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {
        var element = objectSchema[key];
        var propName = element[0];
        var propValue = objectValue[propName];
        unknownKeys["delete"](propName); // Skip mapping for optional properties to avoid creating properties with value 'undefined'

        if (element[1].type().indexOf('Optional<') !== 0 || propValue !== undefined) {
          output[key] = element[1][mappingFn](propValue, ctxt.createChild(propName, propValue, element[1]));
        }
      }
    } // Copy unknown properties over if additional properties flag is set


    if (allowAdditionalProperties) {
      unknownKeys.forEach(function (unknownKey) {
        output[unknownKey] = objectValue[unknownKey];
      });
    }

    return output;
  };
}

function getXmlPropMappingForObjectSchema(objectSchema) {
  var elementsToProps = {};
  var attributesToProps = {};

  for (var key in objectSchema) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {
      var _objectSchema$key = objectSchema[key],
          propName = _objectSchema$key[0],
          xmlOptions = _objectSchema$key[2];

      if ((xmlOptions == null ? void 0 : xmlOptions.isAttr) === true) {
        var _xmlOptions$xmlName;

        attributesToProps[(_xmlOptions$xmlName = xmlOptions.xmlName) != null ? _xmlOptions$xmlName : propName] = key;
      } else {
        var _xmlOptions$xmlName2;

        elementsToProps[(_xmlOptions$xmlName2 = xmlOptions == null ? void 0 : xmlOptions.xmlName) != null ? _xmlOptions$xmlName2 : propName] = key;
      }
    }
  }

  return {
    elementsToProps: elementsToProps,
    attributesToProps: attributesToProps
  };
}

function getPropMappingForObjectSchema(objectSchema) {
  var propsMapping = {};

  for (var key in objectSchema) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {
      var propDef = objectSchema[key];
      propsMapping[propDef[0]] = key;
    }
  }

  return propsMapping;
}

function createReverseObjectSchema(objectSchema) {
  var reverseObjectSchema = {};

  for (var key in objectSchema) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {
      var element = objectSchema[key];
      reverseObjectSchema[element[0]] = [key, element[1], element[2]];
    }
  }

  return reverseObjectSchema;
}

function createXmlObjectSchema(objectSchema) {
  var elementsSchema = {};
  var attributesSchema = {};

  for (var key in objectSchema) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {
      var _xmlOptions$xmlName3;

      var element = objectSchema[key];
      var serializedName = element[0],
          schema = element[1],
          xmlOptions = element[2];
      var xmlObjectSchema = (xmlOptions == null ? void 0 : xmlOptions.isAttr) ? attributesSchema : elementsSchema;
      xmlObjectSchema[key] = [(_xmlOptions$xmlName3 = xmlOptions == null ? void 0 : xmlOptions.xmlName) != null ? _xmlOptions$xmlName3 : serializedName, schema, xmlOptions];
    }
  }

  return {
    elementsSchema: elementsSchema,
    attributesSchema: attributesSchema
  };
}

function createReverseXmlObjectSchema(xmlObjectSchema) {
  return {
    attributesSchema: createReverseObjectSchema(xmlObjectSchema.attributesSchema),
    elementsSchema: createReverseObjectSchema(xmlObjectSchema.elementsSchema)
  };
}

/**
 * Create an optional schema.
 *
 * The optional schema allows 'undefined' or the values allowed by the given
 * 'schema'.
 */
function optional(schema) {
  return {
    type: function type() {
      return "Optional<" + schema.type() + ">";
    },
    validateBeforeMap: function validateBeforeMap(value, ctxt) {
      return value === undefined ? [] : schema.validateBeforeMap(value, ctxt);
    },
    validateBeforeUnmap: function validateBeforeUnmap(value, ctxt) {
      return value === undefined ? [] : schema.validateBeforeUnmap(value, ctxt);
    },
    map: function map(value, ctxt) {
      return value === undefined ? undefined : schema.map(value, ctxt);
    },
    unmap: function unmap(value, ctxt) {
      return value === undefined ? undefined : schema.unmap(value, ctxt);
    },
    validateBeforeMapXml: function validateBeforeMapXml(value, ctxt) {
      return value === undefined ? [] : schema.validateBeforeMapXml(value, ctxt);
    },
    mapXml: function mapXml(value, ctxt) {
      return value === undefined ? undefined : schema.mapXml(value, ctxt);
    },
    unmapXml: function unmapXml(value, ctxt) {
      return value === undefined ? undefined : schema.unmapXml(value, ctxt);
    }
  };
}

function createEnumChecker$1(enumVariable) {
  var enumValues = Object.values(enumVariable);
  return function (value) {
    return typeof value === 'string' && enumValues.includes(value);
  };
}
/**
 * Create a schema for a string enumeration.
 */


function stringEnum(enumVariable) {
  var validate = toValidator(createEnumChecker$1(enumVariable));
  return createSymmetricSchema({
    type: "Enum<" + Object.values(enumVariable).map(literalToString).join(',') + ">",
    map: identityFn,
    validate: validate
  });
}

/**
 * Create an unknown schema.
 *
 * The unknown schema allows any value.
 */

function unknown() {
  return createSymmetricSchema({
    type: 'unknown',
    validate: function validate() {
      return [];
    },
    map: identityFn
  });
}

exports.array = array;
exports.boolean = _boolean;
exports.defaults = defaults;
exports.dict = dict;
exports.dictWithXmlEntries = dictWithXmlEntries;
exports.discriminatedObject = discriminatedObject;
exports.expandoObject = expandoObject;
exports.extendExpandoObject = extendExpandoObject;
exports.extendObject = extendObject;
exports.extendStrictObject = extendStrictObject;
exports.lazy = lazy;
exports.literal = literal;
exports.nullable = nullable;
exports.number = number;
exports.numberEnum = numberEnum;
exports.object = object;
exports.optional = optional;
exports.strictObject = strictObject;
exports.string = string;
exports.stringEnum = stringEnum;
exports.unknown = unknown;
exports.validateAndMap = validateAndMap;
exports.validateAndMapXml = validateAndMapXml;
exports.validateAndUnmap = validateAndUnmap;
exports.validateAndUnmapXml = validateAndUnmapXml;
//# sourceMappingURL=schema.cjs.development.js.map
